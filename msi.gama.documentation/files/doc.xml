<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<doc>
<operatorsCategories>
<category id="Cast"/>
<category id="Graphs"/>
<category id="IContainer"/>
<category id="Queries"/>
<category id="Points"/>
<category id="Strings"/>
<category id="Comparison"/>
<category id="Punctal"/>
<category id="Containers"/>
<category id="Transformations"/>
<category id="Relations"/>
<category id="System"/>
<category id="IMatrix"/>
<category id="Creation"/>
<category id="Files"/>
<category id="Maths"/>
<category id="Colors"/>
<category id="Stats"/>
<category id="GraphsGraphstream"/>
<category id="Random"/>
<category id="Operators"/>
<category id="GamaFileType"/>
<category id="Properties"/>
<category id="Logic"/>
<category id="Statistics"/>
</operatorsCategories>
<operators>
<operator category="Cast" id="to_gaml" name="to_gaml">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="string" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>represents the gaml way to write an expression in gaml, depending on its type</result>
<comment/>
<specialCases/>
<examples>
<example code="to_gaml(0) &#9;&#9;&#9;&#9;&#9;&#9;&#9;--: 0"/>
<example code="to_gaml(3.78) &#9;&#9;&#9;&#9;&#9;&#9;&#9;--: 3.78"/>
<example code="to_gaml(true) &#9;&#9;&#9;&#9;&#9;&#9;&#9;--: true"/>
<example code="to_gaml({23, 4.0}) &#9;&#9;&#9;&#9;&#9;--: {23.0,4.0}"/>
<example code="to_gaml(5::34) &#9;&#9;&#9;&#9;&#9;&#9;--: (5)::(34)"/>
<example code="to_gaml(green) &#9;&#9;&#9;&#9;&#9;&#9;--: rgb (-16711936)"/>
<example code="to_gaml('hello')&#9;&#9;&#9;&#9;&#9;&#9;--: 'hello'"/>
<example code="to_gaml([1,5,9,3]) &#9;&#9;&#9;&#9;&#9;--: [1,5,9,3]"/>
<example code="to_gaml(['a'::345, 'b'::13, 'c'::12])  --:  ([('b')::(13),('c')::(12),('a')::(345)] as map )"/>
<example code="to_gaml([[3,5,7,9],[2,4,6,8]])&#9;&#9;&#9;--: [3,2,5,4,7,6,9,8] as matrix"/>
<example code="to_gaml(a_graph)&#9;&#9;&#9;&#9;&#9;&#9;--: ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph"/>
<example code="to_gaml(node1)&#9;&#9;&#9;&#9;&#9;&#9;&#9;--: 1 as node"/>
</examples>
<seeAlso>
<see id="to_java"/>
</seeAlso>
</documentation>
</operator>
<operator category="IContainer" id="sum" name="sum">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-16">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>the sum of all the elements of the operand</result>
<comment>the sum operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list of int or float: sum returns the sum of all the elements"/>
<case item="if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)"/>
<case item="if it is a population or a list of other types: sum transforms all elements into integer and sums them"/>
<case item="if it is a map, sum returns the sum of the value of all elements"/>
<case item="if it is a file, sum returns the sum of the content of the file (that is also a container)"/>
<case item="if it is a graph, sum returns the sum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)"/>
<case item="if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)"/>
<case item="if it is a matrix of geometry, sum returns the sum of the list of the geometries"/>
<case item="if it is a matrix of other types: sum transforms all elements into float and sums them"/>
</specialCases>
<examples>
<example code="sum ([12,10, 3]) &#9;--: &#9;25.0"/>
<example code="sum([{1.0;3.0},{3.0;5.0},{9.0;1.0},{7.0;8.0}])&#9;&#9;--: {20.0;17.0} "/>
</examples>
<seeAlso>
<see id="mul"/>
</seeAlso>
</documentation>
</operator>
<operator category="Punctal" id="points_at" name="points_at">
<alternativeName/>
<combinaisonIO>
<operands contentType="7" returnType="msi.gama.util.GamaList" type="-13">
<operand name="nbLoc" position="0" type="int"/>
<operand name="distance" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of left-operand number of points located at a the right-operand distance to the agent location.</result>
<comment/>
<specialCases/>
<examples>
<example code="3 points_at(20.0) -&gt; returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location"/>
</examples>
<seeAlso>
<see id="any_location_in"/>
<see id="any_point_in"/>
<see id="closest_points_with"/>
<see id="farthest_point_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="agent" name="agent">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="agent" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to an agent (if a species name is used, casting to an instance of species name).</result>
<comment/>
<specialCases>
<case item="if the operand is a point, returns the closest agent (resp. closest instance of species name) to that point (computed in the topology of the calling agent);"/>
<case item="if the operand is an agent, returns the agent (resp. tries to cast this agent to species name and returns nil if the agent is instance of another species);"/>
<case item="if the operand is an int, returns the agent (resp. instance of species name) with this unique index;"/>
</specialCases>
<examples>
<example code="species node {}"/>
<example code="node(0) &#9;&#9;&#9;--: node0"/>
<example code="node(3.78) &#9;&#9;--: null"/>
<example code="node(true) &#9;&#9;--: null"/>
<example code="node({23, 4.0} &#9;--: node2"/>
<example code="node(5::34) &#9;&#9;--: null"/>
<example code="node(green) &#9;&#9;--: null"/>
<example code="node([1,5,9,3]) &#9;--: null"/>
<example code="node(node1)&#9;&#9;--: node1"/>
<example code="node('4')&#9;&#9;&#9;--: null"/>
</examples>
<seeAlso>
<see id="of_species"/>
<see id="species"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="without_holes" name="without_holes">
<alternativeName>
<altName name="solid"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry corresponding to the operand geometry (geometry, agent, point) without its holes</result>
<comment/>
<specialCases/>
<examples>
<example code="solid(self) -&gt; returns the geometry corresponding to the geometry of the agent applying the operator without its holes."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Relations" id="direction_between" name="direction_between">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="t" position="0" type="topology"/>
<operand name="geometries" position="1" type="msi.gama.util.IContainer&lt;?,msi.gama.metamodel.shape.IShape&gt;"/>
</operands>
</combinaisonIO>
<documentation>
<result>A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.</result>
<comment/>
<specialCases/>
<examples>
<example code="my_topology direction_between [ag1, ag2] -&gt; the direction between ag1 and ag2 considering the topology my_topology"/>
</examples>
<seeAlso>
<see id="towards"/>
<see id="direction_to"/>
<see id="distance_to"/>
<see id="distance_between"/>
<see id="path_between"/>
<see id="path_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="System" id="copy" name="copy">
<alternativeName/>
<combinaisonIO>
<operands contentType="-16" returnType="any" type="-15">
<operand name="o" position="0" type="any"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Creation" id="square" name="square">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="side_size" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A square geometry which side size is equal to the operand.</result>
<comment>the centre of the square is by default the location of the current agent in which has been called this operator.</comment>
<specialCases>
<case item="returns nil if the operand is nil."/>
</specialCases>
<examples>
<example code="square(10) -&gt; returns a geometry as a square of side size 10."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="circle"/>
<see id="cone"/>
<see id="line"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polygon"/>
<see id="polyline"/>
<see id="rectangle"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="Relations" id="distance_between" name="distance_between">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="t" position="0" type="topology"/>
<operand name="geometries" position="1" type="msi.gama.util.IContainer&lt;?,msi.gama.metamodel.shape.IShape&gt;"/>
</operands>
</combinaisonIO>
<documentation>
<result>A distance between a list of geometries (geometries, agents, points) considering a topology.</result>
<comment/>
<specialCases/>
<examples>
<example code="my_topology distance_between [ag1, ag2, ag3] -&gt; the distance between ag1, ag2 and ag3 considering the topology my_topology"/>
</examples>
<seeAlso>
<see id="towards"/>
<see id="direction_to"/>
<see id="distance_to"/>
<see id="direction_between"/>
<see id="path_between"/>
<see id="path_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="is_number" name="is_number">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Transformations" id="as_grid" name="as_grid">
<alternativeName/>
<combinaisonIO>
<operands contentType="13" returnType="matrix" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="dim" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A matrix of square geometries (grid with 8-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)</result>
<comment/>
<specialCases/>
<examples>
<example code="self as_grid {10, 5} -&gt; returns a matrix of square geometries (grid with 8-neighbourhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Files" id="image" name="image">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.file.IGamaFile" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>opens a file that is a kind of image.</result>
<comment>The file should have an image extension, cf. file type deifnition for supported file extensions.</comment>
<specialCases>
<case item="If the specified string does not refer to an existing image file, an exception is risen."/>
</specialCases>
<examples>
<example code="let fileT type: file value: image(&quot;../includes/testImage.png&quot;);  // fileT represents the file &quot;../includes/testShape.png&quot;"/>
</examples>
<seeAlso>
<see id="file"/>
<see id="shapefile"/>
<see id="properties"/>
<see id="text"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="triangle" name="triangle">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="side_size" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A triangle geometry which side size is given by the operand.</result>
<comment>the centre of the triangle is by default the location of the current agent in which has been called this operator.</comment>
<specialCases>
<case item="returns nil if the operand is nil."/>
</specialCases>
<examples>
<example code="triangle(5) -&gt; returns a geometry as a triangle with side_size = 5."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="circle"/>
<see id="cone"/>
<see id="line"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polygon"/>
<see id="polyline"/>
<see id="rectangle"/>
<see id="square"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="as_int" name="as_int">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="string" position="0" type="string"/>
<operand name="radix" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>parses the string argument as a signed integer in the radix specified by the second argument.</result>
<comment/>
<specialCases>
<case item="if the left operand is nil or empty, as_int returns 0"/>
<case item="if the left operand does not represent an integer in the specified radix, as_int throws an exception "/>
</specialCases>
<examples>
<example code="'20' as_int 10 &#9;--: 20;"/>
<example code="'20' as_int 8 &#9;&#9;--: 16;"/>
<example code="'20' as_int 16 &#9;--: 32"/>
<example code="'1F' as_int 16&#9;&#9;--: 31"/>
<example code="'hello' as_int 32 &#9;--: 18306744"/>
</examples>
<seeAlso>
<see id="int"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="polygon" name="polygon">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="points" position="0" type="msi.gama.util.IList&lt;msi.gama.metamodel.shape.GamaPoint&gt;"/>
</operands>
</combinaisonIO>
<documentation>
<result>A polygon geometry from the given list of points.</result>
<comment/>
<specialCases>
<case item="if the operand is nil, returns the point geometry {0,0}"/>
<case item="if the operand is composed of a single point, returns a point geometry"/>
<case item="if the operand is composed of 2 points, returns a polyline geometry."/>
</specialCases>
<examples>
<example code="polygon([{0,0}, {0,10}, {10,10}, {10,0}]) -&gt; returns a polygon geometry composed of the 4 points."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="circle"/>
<see id="cone"/>
<see id="line"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polyline"/>
<see id="rectangle"/>
<see id="square"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="remove_duplicates" name="remove_duplicates">
<alternativeName/>
<combinaisonIO>
<operands contentType="-16" returnType="list" type="-13">
<operand name="l" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>produces a set from the elements of the operand (i.e. a list without duplicated elements)</result>
<comment/>
<specialCases>
<case item="if the operand is nil, remove_duplicates returns nil"/>
<case item="if the operand is a graph, remove_duplicates returns the set of nodes"/>
<case item="if the operand is a map, remove_duplicates returns the set of values without duplicate"/>
<case item="if the operand is a matrix, remove_duplicates returns a matrix withtout duplicated row"/>
</specialCases>
<examples>
<example code="remove_duplicates([3,2,5,1,2,3,5,5,5]) --: [3,2,5,1]"/>
<example code="remove_duplicates([1::3,2::4,3::3,5::7]) --: [3,4,7]"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Stats" id="geometric_mean" name="geometric_mean">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="values" position="0" type="msi.gama.util.GamaList"/>
</operands>
</combinaisonIO>
<documentation>
<result>the geometric mean of the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Geometric_mean"&gt;Geometric_mean&lt;/A&gt; for more details.</result>
<comment>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</comment>
<specialCases/>
<examples>
<example code="geometric_mean ([4.5, 3.5, 5.5, 7.0]) -&gt; 4.962326343467649"/>
</examples>
<seeAlso>
<see id="mean"/>
<see id="median"/>
<see id="harmonic_mean"/>
</seeAlso>
</documentation>
</operator>
<operator category="System" id="." name=".">
<alternativeName>
<altName name="of"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-19" returnType="any" type="-17">
<operand name="a" position="0" type="agent"/>
<operand name="s" position="1" type="any expression"/>
</operands>
</combinaisonIO>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_dot" name="load_graph_from_dot">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following DOT file format.</result>
<comment>DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_dot( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_dot_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="source_of" name="source_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-20">
<operand name="graph" position="0" type="graph"/>
<operand name="edge" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.</result>
<comment/>
<specialCases>
<case item="if the lef-hand operand (the graph) is nil, throws an Exception"/>
</specialCases>
<examples>
<example code="let graphEpidemio type: graph &lt;- generate_barabasi_albert( [&quot;edges_specy&quot;::edge,&quot;vertices_specy&quot;::node,&quot;size&quot;::3,&quot;m&quot;::5] );"/>
<example code="graphEpidemio source_of(edge(3)) &#9;&#9;&#9;&#9;--:  node1"/>
<example code="let graphFromMap type: graph &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);"/>
<example code="graphFromMap source_of(link({1,5}::{12,45}))  &#9;--: {1.0;5.0}"/>
</examples>
<seeAlso>
<see id="target_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="floor" name="floor">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="double" type="-13">
<operand name="d" position="0" type="double"/>
</operands>
</combinaisonIO>
<documentation>
<result>maps the operand to the largest previous following integer.</result>
<comment>More precisely, floor(x) is the largest integer not greater than x.</comment>
<specialCases/>
<examples>
<example code="floor(3) &#9;&#9;--:  3.0"/>
<example code="floor(3.5) &#9;--:  3.0"/>
<example code="floor(-4.7) &#9;--:  -5.0"/>
</examples>
<seeAlso>
<see id="ceil"/>
<see id="round"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="even" name="even">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if the operand is even and false if it is odd.</result>
<comment/>
<specialCases>
<case item="if the operand is equal to 0, it returns true."/>
</specialCases>
<examples>
<example code="even (3) &#9;--:   false"/>
<example code="even (-12)   --:  true"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Cast" id="path" name="path">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="path" type="-13">
<operand name="object" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a path</result>
<comment/>
<specialCases>
<case item="if the operand is a path, returns itself"/>
<case item="if the operand is a list, casts the list into a list of point and returns the path (in the current topology) through these points."/>
<case item="otherwise, returns nil"/>
</specialCases>
<examples>
<example code="path([{2,5}, {4,7}, {2,1}])   --:  [polyline ([{2.0,5.0},{4.0,7.0}]),polyline ([{4.0,7.0},{2.0,1.0}])]"/>
</examples>
<seeAlso>
<see id="graph"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="with_min_of" name="with_min_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-20">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>one of elements of the left-hand operand that minimizes the value of the right-hand operand</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] with_min_of (each ) &#9;&#9;&#9;&#9;&#9;&#9;--: &#9;1"/>
<example code="g2 with_min_of (length(g2 out_edges_of each)  ) &#9;&#9;&#9;--: &#9;node11"/>
<example code="(list(node) with_min_of (round(node(each).location.x))    &#9;--:  &#9;node0"/>
<example code="[1::2, 3::4, 5::6] with_min_of (each) &#9;&#9;&#9;&#9;&#9;&#9;--: &#9;2"/>
</examples>
<seeAlso>
<see id="where"/>
<see id="with_max_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Comparison" id="=" name="=">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="any"/>
<operand name="b" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if both operands are equal, false otherwise</result>
<comment>this operator will return true if the two operands are identical (i.e., the same object) or equal. Comparisons between nil values are permitted.</comment>
<specialCases/>
<examples>
<example code="3.0 = 3  &#9;--:  true"/>
<example code="[2,3] = [2,3] --: true"/>
<example code="3 = 3    &#9;--: true"/>
<example code="4.5 = 4.7  &#9;--:  false"/>
</examples>
<seeAlso>
<see id="!="/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="bool" name="bool">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a boolean value.</result>
<comment/>
<specialCases>
<case item="if the operand is null, returns false;"/>
<case item="if the operand is an agent, returns true if the agent is not dead;"/>
<case item="if the operand is an int or a float, returns true if it is not equal to 0 (or 0.0);"/>
<case item="if the operand is a file, bool is formally equivalent to exists;"/>
<case item="if the operand is a container, bool is formally equivalent to not empty (a la Lisp);"/>
<case item="if the operand is a string, returns true is the operand is true;"/>
<case item="Otherwise, returns false."/>
</specialCases>
<examples>
<example code="bool(3.78) &#9;&#9;--: true"/>
<example code="bool(true) &#9;&#9;--: true"/>
<example code="bool({23, 4.0} &#9;--: false"/>
<example code="bool(5::34) &#9;&#9;--: false"/>
<example code="bool(green) &#9;&#9;--: false"/>
<example code="bool([1,5,9,3]) &#9;--: true"/>
<example code="bool(node1)&#9;&#9;--: true"/>
<example code="bool('4')&#9;&#9;&#9;--: false"/>
<example code="bool('4.7')&#9;&#9;--: false "/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Queries" id="agents_overlapping" name="agents_overlapping">
<alternativeName/>
<combinaisonIO>
<operands contentType="11" returnType="list of points" type="-13">
<operand name="toBeCastedIntoGeometry" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agents overlapping the operand (casted as a geometry).</result>
<comment/>
<specialCases/>
<examples>
<example code="agents_overlapping(self) -&gt; return the agents that overlap the shape of the agent applying the operator."/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="agent_closest_to"/>
<see id="agents_inside"/>
<see id="closest_to"/>
<see id="inside"/>
<see id="overlapping"/>
<see id="at_distance"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="contains_edge" name="contains_edge">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="edge" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="edge" position="1" type="pair"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise</result>
<comment/>
<specialCases>
<case item="if the left-hand operand is nil, returns false"/>
<case item="if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph"/>
</specialCases>
<examples>
<example code="let graphFromMap type: graph &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);"/>
<example code="graphFromMap contains_edge link({1,5}::{12,45})  --: true"/>
<example code="let graphEpidemio type: graph &lt;- generate_barabasi_albert( [&quot;edges_specy&quot;::edge,&quot;vertices_specy&quot;::node,&quot;size&quot;::3,&quot;m&quot;::5] );"/>
<example code="graphEpidemio contains_edge (node(0)::node(3));   --:   true"/>
</examples>
<seeAlso>
<see id="contains_vertex"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="max_of" name="max_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-17">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, max_of returns the right-hand operand default value"/>
</specialCases>
<examples>
<example code="[1,2,4,3,5,7,6,8] max_of (each * 100 ) &#9;&#9;&#9;--: &#9;800"/>
<example code="g2 max_of (length(g2 out_edges_of each) ) &#9;&#9;&#9;--: &#9;3"/>
<example code="(list(node) max_of (round(node(each).location.x))  --: &#9;96"/>
<example code="[1::2, 3::4, 5::6] max_of (each.value + 3) &#9;&#9;--: &#9;9"/>
</examples>
<seeAlso>
<see id="min_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Files" id="new_folder" name="new_folder">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.file.IGamaFile" type="-13">
<operand name="folder" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>opens an existing repository or create a new folder if it does not exist.</result>
<comment/>
<specialCases>
<case item=" If the specified string does not refer to an existing repository, the repository is created. If the string refers to an existing file, an exception is risen."/>
</specialCases>
<examples>
<example code="let dirNewT type: file value: new_folder(&quot;../incl/&quot;);   &#9;// dirNewT represents the repository &quot;../incl/&quot;"/>
<example code="&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// eventually creates the directory ../incl"/>
</examples>
<seeAlso>
<see id="folder"/>
<see id="file"/>
</seeAlso>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_pajek" name="load_graph_from_pajek">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following Pajek file format.</result>
<comment>Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_pajek( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_Pajek_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="as_4_grid" name="as_4_grid">
<alternativeName/>
<combinaisonIO>
<operands contentType="13" returnType="matrix" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="dim" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A matrix of square geometries (grid with 4-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)</result>
<comment/>
<specialCases/>
<examples>
<example code="self as_grid {10, 5} -&gt; returns matrix of square geometries (grid with 4-neighbourhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="IMatrix" id="rows_list" name="rows_list">
<alternativeName/>
<combinaisonIO>
<operands contentType="5" returnType="msi.gama.util.IList&lt;msi.gama.util.IList&lt;T&gt;&gt;" type="-13">
<operand name="msi.gama.util.matrix.imatrix&lt;t&gt;" position="0" type="matrix"/>
</operands>
</combinaisonIO>
</operator>
<operator category="System" id="user_input" name="user_input">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="java.util.Map&lt;java.lang.String,java.lang.Object&gt;" type="-13">
<operand name="initialValues" position="0" type="java.util.Map&lt;java.lang.String,java.lang.Object&gt;"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Stats" id="frequency_of" name="frequency_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="map" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)</result>
<comment/>
<specialCases/>
<examples>
<example code="[ag1, ag2, ag3, ag4] frequency_of each.size &#9;--:   will return the different sizes as keys and the number of agents of this size as values"/>
</examples>
<seeAlso>
<see id="as_map"/>
</seeAlso>
</documentation>
</operator>
<operator category="System" id="dead" name="dead">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="agent"/>
</operands>
</combinaisonIO>
</operator>
<operator category="IContainer" id="mul" name="mul">
<alternativeName>
<altName name="product"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-16">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>the product of all the elements of the operand</result>
<comment>the mul operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list of int or float: mul returns the product of all the elements"/>
<case item="if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)"/>
<case item="if it is a list of other types: mul transforms all elements into integer and multiplies them"/>
<case item="if it is a map, mul returns the product of the value of all elements"/>
<case item="if it is a file, mul returns the product of the content of the file (that is also a container)"/>
<case item="if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)"/>
<case item="if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)"/>
<case item="if it is a matrix of geometry, mul returns the product of the list of the geometries"/>
<case item="if it is a matrix of other types: mul transforms all elements into float and multiplies them"/>
</specialCases>
<examples>
<example code="mul ([100, 23.2, 34.5]) &#9;--:&#9;&#9;80040.0"/>
</examples>
<seeAlso>
<see id="sum"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="predecessors_of" name="predecessors_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="list" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="vertex" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)</result>
<comment/>
<specialCases/>
<examples>
<example code="graphEpidemio predecessors_of (node(3)) &#9;&#9;--: [node0,node2]"/>
<example code="graphFromMap predecessors_of node({12,45}) &#9;--:&#9;[{1.0;5.0}]"/>
</examples>
<seeAlso>
<see id="neighbours_of"/>
<see id="successors_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_edge" name="load_graph_from_edge">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following Edge file format.</result>
<comment>This format is a simple text file with numeric vertex ids defining the edges. The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_edge( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_edge_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="GamaFileType" id="is_shape" name="is_shape">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="f" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>the operator tests whether the operand represents the name of a supported shapefile</result>
<comment>cf. file type definition for supported (espacially image) file extensions.</comment>
<specialCases/>
<examples>
<example code="is_shape(&quot;../includes/Stupid_Cell.Data&quot;)    --:  false;"/>
<example code="is_shape(&quot;../includes/test.png&quot;)            --:  false;"/>
<example code="is_shape(&quot;../includes/test.properties&quot;)     --:  false;"/>
<example code="is_shape(&quot;../includes/test.shp&quot;)            --:  true;"/>
</examples>
<seeAlso>
<see id="image"/>
<see id="is_text"/>
<see id="is_properties"/>
<see id="is_image"/>
</seeAlso>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_dgs" name="load_graph_from_dgs">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following DGS graph file format versions 1 and 2</result>
<comment>similar to load_graph_from_dgs_old</comment>
<specialCases/>
<examples/>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="IMatrix" id="columns_list" name="columns_list">
<alternativeName/>
<combinaisonIO>
<operands contentType="5" returnType="msi.gama.util.IList&lt;msi.gama.util.IList&lt;T&gt;&gt;" type="-13">
<operand name="msi.gama.util.matrix.imatrix&lt;t&gt;" position="0" type="matrix"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Relations" id="distance_to" name="distance_to">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="source" position="0" type="point"/>
<operand name="target" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="source" position="0" type="shape"/>
<operand name="target" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.</result>
<comment/>
<specialCases/>
<examples>
<example code="ag1 distance_to ag2 -&gt; the distance between ag1 and ag2 considering the topology of the agent applying the operator"/>
</examples>
<seeAlso>
<see id="towards"/>
<see id="direction_to"/>
<see id="distance_between"/>
<see id="direction_between"/>
<see id="path_between"/>
<see id="path_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="as_intersection_graph" name="as_intersection_graph">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="vertices" position="0" type="container"/>
<operand name="tolerance" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).</result>
<comment>as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.</comment>
<specialCases/>
<examples>
<example code="list(ant) as_intersection_graph 0.5;"/>
</examples>
<seeAlso>
<see id="as_distance_graph"/>
<see id="as_edge_graph"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="clean" name="clean">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry corresponding to the cleaning of the operand (geometry, agent, point)</result>
<comment>The cleaning corresponds to a buffer with a distance of 0.0</comment>
<specialCases/>
<examples>
<example code="cleaning(self) -&gt; returns the geometry resulting from the cleaning of the geometry of the agent applying the operator."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Containers" id="accumulate" name="accumulate">
<alternativeName/>
<combinaisonIO>
<operands contentType="-19" returnType="list" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned</result>
<comment>accumulate is dedicated to the application of a same computation on each element of a container (and returns a list) In the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, accumulate returns an empty list"/>
</specialCases>
<examples>
<example code="[a1,a2,a3] accumulate (each neighbours_at 10)  &#9;&#9;--: &#9;a flat list of all the neighbours of these three agents"/>
<example code="[1,2,4] accumulate ([2,4])  &#9;&#9;--: &#9;[2,4,2,4,2,4]"/>
</examples>
<seeAlso>
<see id="collect"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="copy_between" name="copy_between">
<alternativeName/>
<documentation>
<result>returns a copy of a sublist of the left operand between a begin index (x of the right operand point) and a end index (y of the right operand point</result>
<comment>copy_between can only be used on list (and string)</comment>
<specialCases>
<case item="if the right operand is nil or empty, copy_between returns a copy of the left operand"/>
<case item="if the begin index is higher than the end index, copy_between returns a new empty list"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7] copy_between {0,3} &#9;--:&#9;&#9; [1,2,3]"/>
</examples>
<seeAlso/>
</documentation>
<combinaisonIO>
<operands contentType="-20" returnType="list" type="-13">
<operand name="l1" position="0" type="list"/>
<operand name="p" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="string" type="-13">
<operand name="target" position="0" type="string"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Random" id="poisson" name="poisson">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="mean" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).</result>
<comment>The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.</comment>
<specialCases/>
<examples>
<example code="poisson(3.5) -&gt; a random positive integer"/>
</examples>
<seeAlso>
<see id="binomial"/>
<see id="gauss"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="of_generic_species" name="of_generic_species">
<alternativeName/>
<combinaisonIO>
<operands contentType="-19" returnType="list" type="-13">
<operand name="agents" position="0" type="container"/>
<operand name="s" position="1" type="species"/>
</operands>
</combinaisonIO>
<documentation>
<result>a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species </result>
<comment/>
<specialCases/>
<examples>
<example code="// species test {}"/>
<example code="// species sous_test parent: test {}"/>
<example code="[sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test &#9;&#9;--: [sous_test0,sous_test1,test2,test3]"/>
<example code="[sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test &#9;--: [sous_test0,sous_test1]"/>
<example code="[sous_test(0),sous_test(1),test(2),test(3)] of_species test &#9;&#9;&#9;&#9;--: [test2,test3]"/>
<example code="[sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test &#9;&#9;&#9;--: [sous_test0,sous_test1]"/>
</examples>
<seeAlso>
<see id="of_species"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="among" name="among">
<alternativeName/>
<combinaisonIO>
<operands contentType="-19" returnType="map" type="-13">
<operand name="number" position="0" type="int"/>
<operand name="l" position="1" type="map"/>
</operands>
<operands contentType="-19" returnType="list" type="-13">
<operand name="number" position="0" type="int"/>
<operand name="c" position="1" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>a list of length the value of the left-hand operand, containing random elements from the right-hand operand</result>
<comment/>
<specialCases>
<case item="if the right-hand operand is a map, among returns a map of right-hand operand element instead of a list"/>
<case item="if the right-hand operand is empty or nil, among returns a new empty list"/>
<case item="if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand."/>
</specialCases>
<examples>
<example code="2 among [1::2, 3::4, 5::6] &#9;--: &#9;[1::2, 3::4]"/>
<example code="3 among [1,2,4,3,5,7,6,8] &#9;&#9;--: &#9;[1,2,8]"/>
<example code="3 among g2 &#9;&#9;&#9;&#9;&#9;--: &#9;[node6,node11,node7]"/>
<example code="3 among list(node)    &#9;&#9;&#9;--:  &#9;[node1,node11,node4]"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Punctal" id="any_location_in" name="any_location_in">
<alternativeName>
<altName name="any_point_in"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="point" type="-13">
<operand name="g" position="0" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A point inside (or touching) the operand-geometry.</result>
<comment/>
<specialCases/>
<examples>
<example code="any_location_in(square(5)) -&gt; a point of the square, for example : {3,4.6}."/>
</examples>
<seeAlso>
<see id="closest_points_with"/>
<see id="farthest_point_to"/>
<see id="points_at"/>
</seeAlso>
</documentation>
</operator>
<operator category="Points" id="norm" name="norm">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="p" position="0" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>the norm of the vector with the coordinnates of the point operand.</result>
<comment/>
<specialCases/>
<examples>
<example code="norm({3,4})   --:&#9;  5.0"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Transformations" id="skeletonize" name="skeletonize">
<alternativeName/>
<combinaisonIO>
<operands contentType="13" returnType="msi.gama.util.GamaList&lt;msi.gama.metamodel.shape.IShape&gt;" type="-13">
<operand name="g" position="0" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)</result>
<comment/>
<specialCases/>
<examples>
<example code="skeletonize(self) -&gt; returns the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="IContainer" id="empty" name="empty">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="boolean" type="-13">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if the operand is empty, false otherwise.</result>
<comment>the empty operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list, empty returns true if there is no element in the list, and false otherwise"/>
<case item="if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise"/>
<case item="if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise"/>
<case item="if it is a population, empty returns true if there is no agent in the population, and false otherwise"/>
<case item="if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise"/>
<case item="if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise"/>
<case item="if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise"/>
<case item="if it is a string, empty returns true if the string does not contain any character, and false otherwise"/>
</specialCases>
<examples>
<example code="empty ([]) &#9;--: &#9;true;"/>
<example code="empty ('abced') &#9;--: &#9;false"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Files" id="shapefile" name="shapefile">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.file.IGamaFile" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>opens a file that a is a kind of shapefile.</result>
<comment>The file should have a shapefile extension, cf. file type definition for supported file extensions.</comment>
<specialCases>
<case item="If the specified string does not refer to an existing shapefile file, an exception is risen."/>
</specialCases>
<examples>
<example code="let fileT type: file value: shapefile(&quot;../includes/testProperties.shp&quot;);"/>
<example code="            // fileT represents the shapefile file &quot;../includes/testProperties.shp&quot;"/>
</examples>
<seeAlso>
<see id="file"/>
<see id="properties"/>
<see id="image"/>
<see id="text"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="where" name="where">
<alternativeName>
<altName name="select"/>
</alternativeName>
<documentation>
<result>a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true. </result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is a list nil, where returns a new empty list"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] where (each &gt; 3) &#9;&#9;&#9;&#9;&#9;&#9;--: &#9;[4, 5, 6, 7, 8] "/>
<example code="g2 where (length(g2 out_edges_of each) = 0 ) &#9;&#9;&#9;&#9;--: &#9;[node9, node7, node10, node8, node11]"/>
<example code="(list(node) where (round(node(each).location.x) &gt; 32)   &#9;--:  &#9;[node2, node3]"/>
<example code="[1::2, 3::4, 5::6] where (each.value &gt; 4) &#9;&#9;&#9;&#9;&#9;&#9;--: &#9;"/>
</examples>
<seeAlso>
<see id="first_with"/>
<see id="last_with"/>
<see id="where"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-20" returnType="list" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
<operands contentType="-13" returnType="map" type="-13">
<operand name="original" position="0" type="map"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
</operator>
<operator category="System" id="eval_java" name="eval_java">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-13">
<operand name="code" position="0" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="System" id="every" name="every">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="period" position="0" type="int"/>
</operands>
</combinaisonIO>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_dgs_old" name="load_graph_from_dgs_old">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following DGS file format (version 3).</result>
<comment>DGS is a file format allowing to store graphs and dynamic graphs in a textual human readable way, yet with a small size allowing to store large graphs. Graph dynamics is defined using events like adding, deleting or changing a node or edge. With DGS, graphs will therefore be seen as stream of such events. [From GraphStream related page: http://graphstream-project.org/]The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_dgs_old( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;../includes/BarabasiGenerated.dgs&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="link" name="link">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="points" position="0" type="pair"/>
</operands>
</combinaisonIO>
<documentation>
<result>A link between the 2 elements of the pair.</result>
<comment>The geometry of the link is the intersection of the two geometries when they intersect, and a line between their centroids when they do not.</comment>
<specialCases>
<case item="if the operand is nil, link returns a point {0,0}"/>
<case item="if one of the elements of the pair is a list of geometries or a species, link will consider the union of the geometries or of the geometry of each agent of the species"/>
</specialCases>
<examples>
<example code="link (geom1::geom2)  -&gt; returns a link geometry between geom1 and geom2."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="circle"/>
<see id="cone"/>
<see id="line"/>
<see id="norm"/>
<see id="point"/>
<see id="polygon"/>
<see id="polyline"/>
<see id="rectangle"/>
<see id="square"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="Stats" id="variance" name="variance">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="values" position="0" type="msi.gama.util.GamaList"/>
</operands>
</combinaisonIO>
<documentation>
<result>the variance of the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Variance"&gt;Variance&lt;/A&gt; for more details.</result>
<comment>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. </comment>
<specialCases/>
<examples>
<example code="variance ([4.5, 3.5, 5.5, 7.0]) -&gt; 1.671875&#9;"/>
</examples>
<seeAlso>
<see id="mean"/>
<see id="median"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="first_with" name="first_with">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-20">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>the first element of the left-hand operand that makes the right-hand operand evaluate to true.</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, first_with returns nil"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] first_with (each &gt; 3) &#9;&#9;&#9;&#9;&#9;&#9;--: &#9;4"/>
<example code="g2 first_with (length(g2 out_edges_of each) = 0) &#9;&#9;&#9;&#9;--: &#9;node9"/>
<example code="(list(node) first_with (round(node(each).location.x) &gt; 32)   &#9;--: &#9;node2"/>
<example code="[1::2, 3::4, 5::6] first_with (each.key &gt; 4) &#9;&#9;&#9;&#9;&#9;--: &#9;5::6"/>
</examples>
<seeAlso>
<see id="group_by"/>
<see id="last_with"/>
<see id="where"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="as_distance_graph" name="as_distance_graph">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="vertices" position="0" type="container"/>
<operand name="distance" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).</result>
<comment>as_distance_graph is more efficient for a list of points than as_intersection_graph.</comment>
<specialCases/>
<examples>
<example code="list(ant) as_distance_graph 3.0;"/>
</examples>
<seeAlso>
<see id="as_intersection_graph"/>
<see id="as_edge_graph"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="line" name="line">
<alternativeName>
<altName name="polyline"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="points" position="0" type="msi.gama.util.IList&lt;msi.gama.metamodel.shape.GamaPoint&gt;"/>
</operands>
</combinaisonIO>
<documentation>
<result>A polyline geometry from the given list of points.</result>
<comment/>
<specialCases>
<case item="if the operand is nil, returns the point geometry {0,0}"/>
<case item="if the operand is composed of a single point, returns a point geometry."/>
</specialCases>
<examples>
<example code="polyline([{0,0}, {0,10}, {10,10}, {10,0}]) -&gt; returns a polyline geometry composed of the 4 points."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="circle"/>
<see id="cone"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polygone"/>
<see id="rectangle"/>
<see id="square"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="list" name="list">
<alternativeName/>
<documentation>
<result>transforms the operand into a list</result>
<comment>list always tries to cast the operand except if it is an int, a bool or a float; to create a list, instead, containing the operand (including another list), use the + operator on an empty list (like [] + 'abc').</comment>
<specialCases>
<case item="if the operand is a point or a pair, returns a list containing its components (two coordinates or the key and the value);"/>
<case item="if the operand is a rgb color, returns a list containing its three integer components;"/>
<case item="if the operand is a file, returns its contents as a list;"/>
<case item="if the operand is a matrix, returns a list containing its elements;"/>
<case item="if the operand is a graph, returns the list of vetices or edges (depending on the graph)"/>
<case item="if the operand is a species, return a list of its agents;"/>
<case item="if the operand is a string, returns a list of strings, each containing one character;"/>
<case item="otherwise returns a list containing the operand."/>
</specialCases>
<examples>
<example code=""/>
</examples>
<seeAlso/>
</documentation>
<combinaisonIO>
<operands contentType="-16" returnType="list" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
<operands contentType="-16" returnType="list" type="-13">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Cast" id="as" name="as">
<alternativeName/>
<combinaisonIO>
<operands contentType="-19" returnType="agent" type="-19">
<operand name="val" position="0" type="any"/>
<operand name="species" position="1" type="species"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the left-hand operand to a species.</result>
<comment/>
<specialCases>
<case item="if the right-hand operand is nil, transforms the left-hand operand into an agent"/>
<case item="if the left-hand operand is nil, returns nil"/>
<case item="if the left-hand operand is an agent, if the right-hand is a agent, returns it, otherwise returns nil"/>
<case item="if the left-oprand is a integer, returns an agent with the right-operans as id"/>
<case item="if the left-operand is a poiny, returns the agent the closest to right-hand operand"/>
<case item="otherwise, returns nil"/>
</specialCases>
<examples/>
<seeAlso>
<see id="agent"/>
</seeAlso>
</documentation>
</operator>
<operator category="Logic" id="or" name="or">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="left" position="0" type="bool"/>
<operand name="right" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>a bool value, equal to the logical or between the left-hand operand and the rigth-hand operand.</result>
<comment>both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.</comment>
<specialCases/>
<examples/>
<seeAlso>
<see id="bool"/>
<see id="and"/>
</seeAlso>
</documentation>
</operator>
<operator category="Random" id="flip" name="flip">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="probability" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>true or false given the probability represented by the operand</result>
<comment/>
<specialCases>
<case item="flip 0 always returns false, flip 1 true"/>
</specialCases>
<examples>
<example code="flip (0.66666) -&gt; 2/3 chances to return true."/>
</examples>
<seeAlso>
<see id="rnd"/>
</seeAlso>
</documentation>
</operator>
<operator category="System" id="evaluate_with" name="evaluate_with">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-13">
<operand name="code" position="0" type="string"/>
<operand name="parameters" position="1" type="any expression"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Cast" id="point" name="point">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="point" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a point value.</result>
<comment/>
<specialCases>
<case item="if the operand is null, returns null;"/>
<case item="if the operand is an agent, returns its location"/>
<case item="if the operand is a geometry, returns its centroid"/>
<case item="if the operand is a list with at least two elements, returns a point with the two first elements of the list (casted to float)"/>
<case item="if the operand is a map, returns the point with values associated respectively with keys &quot;x&quot; and &quot;y&quot;"/>
<case item="if the operand is a pair, returns a point with the two elements of the pair (casted to float)"/>
<case item="otherwise, returns a point {val,val} where val is the float value of the operand"/>
</specialCases>
<examples>
<example code="point(0) &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--: {0.0;0.0}"/>
<example code="point(true) &#9;&#9;&#9;&#9;&#9;&#9;&#9;--: {1.0;1.0}"/>
<example code="point(5::34) &#9;&#9;&#9;&#9;&#9;&#9;&#9;--: {5.0;34.0}"/>
<example code="point([1,5,9,3]) &#9;&#9;&#9;&#9;&#9;&#9;--: {1.0;5.0}"/>
<example code="point([[3,7],[2,6,9],0]) &#9;&#9;&#9;&#9;--:{0.0;0.0}"/>
<example code="point(['a'::345, 'y'::13, 'c'::12])  &#9;--:  {0.0;13.0}"/>
<example code="point(node1)&#9;&#9;&#9;&#9;&#9;&#9;&#9;--: {64.06165572529225;18.401233796267537}   // centroid of node1 shape"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Transformations" id="at_location" name="at_location">
<alternativeName>
<altName name="translated_to"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)</result>
<comment/>
<specialCases/>
<examples>
<example code="self at_location {10, 20} -&gt; returns the geometry resulting from a translation to the location {10, 20} of the geometry of the agent applying the operator."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Transformations" id="convex_hull" name="convex_hull">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry corresponding to the convex hull of the operand.</result>
<comment/>
<specialCases/>
<examples>
<example code="convex_hull(self) -&gt; returns the convex hull of the geometry of the agent applying the operator"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Stats" id="standard_deviation" name="standard_deviation">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="values" position="0" type="msi.gama.util.GamaList"/>
</operands>
</combinaisonIO>
<documentation>
<result>the standard deviation on the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Standard_deviation"&gt;Standard_deviation&lt;/A&gt; for more details.</result>
<comment>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</comment>
<specialCases/>
<examples>
<example code="standard_deviation ([4.5, 3.5, 5.5, 7.0]) -&gt; 1.2930100540985752"/>
</examples>
<seeAlso>
<see id="mean"/>
<see id="mean_deviation"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="cone" name="cone">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="p" position="0" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A cone geometry which min and max angles are given by the operands.</result>
<comment>the centre of the cone is by default the location of the current agent in which has been called this operator.</comment>
<specialCases>
<case item="returns nil if the operand is nil."/>
</specialCases>
<examples>
<example code="cone({0, 45}) -&gt; returns a geometry as a cone with min angle is 0 and max angle is 45."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="circle"/>
<see id="line"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polygon"/>
<see id="polyline"/>
<see id="rectangle"/>
<see id="square"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="topology" name="topology">
<alternativeName/>
<combinaisonIO>
<operands contentType="13" returnType="topology" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a topology.</result>
<comment/>
<specialCases>
<case item="if the operand is a topology, returns the topology itself;"/>
<case item="if the operand is a spatial graph, returns the graph topology associated;"/>
<case item="if the operand is a population, returns the topology of the population;"/>
<case item="if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;"/>
<case item="if the operand is a matrix, returns the grid topology associated"/>
<case item="if the operand is another kind of container, returns the multiple topology associated to the container"/>
<case item="otherwise, casts the operand to a geometry and build a topology from it."/>
</specialCases>
<examples>
<example code="topology(0) &#9;&#9;--: null"/>
<example code="topology(a_graph)&#9;--: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]"/>
</examples>
<seeAlso>
<see id="geometry"/>
</seeAlso>
</documentation>
</operator>
<operator category="IMatrix" id="row_at" name="row_at">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="msi.gama.util.IList&lt;T&gt;" type="-13">
<operand name="msi.gama.util.matrix.imatrix&lt;t&gt;" position="0" type="matrix"/>
<operand name="num_line" position="1" type="int"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Strings" id="length" name="length">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="s" position="0" type="species"/>
</operands>
</combinaisonIO>
<documentation>
<result>the number of elements contained in the operand</result>
<comment>the length operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a string, length returns the number of characters"/>
<case item="if it is a list or a map, length returns the number of elements in the list or map"/>
<case item="if it is a population, length returns number of agents of the population"/>
<case item="if it is a graph, last returns the number of vertexes or of edges (depending on the way it was created)"/>
<case item="if it is a matrix, length returns the number of cells"/>
</specialCases>
<examples>
<example code="length ('I am an agent') &#9;&#9;--: &#9;13"/>
<example code="length ([12,13])&#9;--: &#9;2"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="GamaFileType" id="is_image" name="is_image">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="f" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>the operator tests whether the operand represents the name of a supported image file</result>
<comment>cf. file type definition for supported (espacially image) file extensions.</comment>
<specialCases/>
<examples>
<example code="is_image(&quot;../includes/Stupid_Cell.Data&quot;)    --:  false;"/>
<example code="is_image(&quot;../includes/test.png&quot;)            --:  true;"/>
<example code="is_image(&quot;../includes/test.properties&quot;)     --:  false;"/>
<example code="is_image(&quot;../includes/test.shp&quot;)            --:  false;"/>
</examples>
<seeAlso>
<see id="image"/>
<see id="is_text"/>
<see id="is_properties"/>
<see id="is_shape"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="contains_vertex" name="contains_vertex">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="graph" position="0" type="msi.gama.util.graph.GamaGraph"/>
<operand name="vertex" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise</result>
<comment/>
<specialCases>
<case item="if the left-hand operand is nil, returns false"/>
</specialCases>
<examples>
<example code="let graphFromMap type: graph &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);"/>
<example code="graphFromMap contains_vertex {1,5}  --: true"/>
</examples>
<seeAlso>
<see id="contains_edge"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="last_with" name="last_with">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-20">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>the last element of the left-hand operand that makes the right-hand operand evaluate to true.</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, last_with returns nil"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] last_with (each &gt; 3) &#9;&#9;&#9;&#9;&#9;--: &#9;8"/>
<example code="g2 last_with (length(g2 out_edges_of each) = 0 ) &#9;&#9;&#9;--: &#9;node11"/>
<example code="(list(node) last_with (round(node(each).location.x) &gt; 32)  --: &#9;node3"/>
<example code="[1::2, 3::4, 5::6] last_with (each.key &gt; 4) &#9;&#9;&#9;&#9;--: &#9;5::6"/>
</examples>
<seeAlso>
<see id="group_by"/>
<see id="first_with"/>
<see id="where"/>
</seeAlso>
</documentation>
</operator>
<operator category="Stats" id="mean_deviation" name="mean_deviation">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="values" position="0" type="msi.gama.util.GamaList"/>
</operands>
</combinaisonIO>
<documentation>
<result>the deviation from the mean of all the elements of the operand. See &lt;A href= "http://en.wikipedia.org/wiki/Absolute_deviation" &gt;Mean_deviation&lt;/A&gt; for more details.</result>
<comment>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</comment>
<specialCases/>
<examples>
<example code="mean_deviation ([4.5, 3.5, 5.5, 7.0]) -&gt; 1.125"/>
</examples>
<seeAlso>
<see id="mean"/>
<see id="standard_deviation"/>
</seeAlso>
</documentation>
</operator>
<operator category="Properties" id="partially_overlaps" name="partially_overlaps">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).</result>
<comment>if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).</comment>
<specialCases>
<case item="if one of the operand is null, returns false."/>
</specialCases>
<examples>
<example code="polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps geometry({25,25}) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps geometry({15,15}) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]) -&gt; false"/>
</examples>
<seeAlso>
<see id="&lt;-&gt;"/>
<see id="disjoint_from"/>
<see id="crosses"/>
<see id="overlaps"/>
<see id="intersects"/>
<see id="touches"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="in_edges_of" name="in_edges_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="list" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="vertex" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.</result>
<comment/>
<specialCases/>
<examples>
<example code="graphEpidemio in_edges_of (node(3))   --:  [edge2,edge3]"/>
<example code="graphFromMap in_edges_of node({12,45})  --:  [LineString]"/>
</examples>
<seeAlso>
<see id="out_edges_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Properties" id="intersects" name="intersects">
<alternativeName/>
<documentation>
<result>A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).</result>
<comment/>
<specialCases>
<case item="if one of the operand is null, returns false."/>
</specialCases>
<examples>
<example code="square(5) intersects {10,10} -&gt; false."/>
</examples>
<seeAlso>
<see id="&lt;-&gt;"/>
<see id="disjoint_from"/>
<see id="crosses"/>
<see id="overlaps"/>
<see id="partially_overlaps"/>
<see id="touches"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Relations" id="towards" name="towards">
<alternativeName>
<altName name="direction_to"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="agent" position="0" type="shape"/>
<operand name="target" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.</result>
<comment/>
<specialCases/>
<examples>
<example code="ag1 towards ag2 -&gt; the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator"/>
</examples>
<seeAlso>
<see id="distance_between"/>
<see id="distance_to"/>
<see id="direction_between"/>
<see id="path_between"/>
<see id="path_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="Random" id="truncated_gauss" name="truncated_gauss">
<alternativeName>
<altName name="TGauss"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="p" position="0" type="point"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="list" position="0" type="list"/>
</operands>
</combinaisonIO>
<documentation>
<result>A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.</result>
<comment/>
<specialCases>
<case item="when the operand is a point, it is read as {mean, standardDeviation}"/>
<case item="if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]"/>
<case item="when truncated_gauss is called with a list of only one element mean, it will always return 0.0"/>
</specialCases>
<examples>
<example code="truncated_gauss ({0, 0.3})  -&gt;  an float between -0.3 and 0.3"/>
<example code="truncated_gauss ([0.5, 0.0])  -&gt;  0.5 (always)"/>
</examples>
<seeAlso>
<see id="gauss"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="with_max_of" name="with_max_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-20">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>one of elements of the left-hand operand that maximizes the value of the right-hand operand</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] with_max_of (each ) &#9;&#9;&#9;&#9;&#9;&#9;--: &#9;8"/>
<example code="g2 with_max_of (length(g2 out_edges_of each)  ) &#9;&#9;&#9;--: &#9;node4"/>
<example code="(list(node) with_max_of (round(node(each).location.x))    &#9;--:  &#9;node3"/>
<example code="[1::2, 3::4, 5::6] with_max_of (each) &#9;&#9;&#9;&#9;&#9;&#9;--: &#9;6"/>
</examples>
<seeAlso>
<see id="where"/>
<see id="with_min_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="target_of" name="target_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-20">
<operand name="graph" position="0" type="graph"/>
<operand name="edge" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.</result>
<comment/>
<specialCases>
<case item="if the lef-hand operand (the graph) is nil, returns nil"/>
</specialCases>
<examples>
<example code="let graphEpidemio type: graph &lt;- generate_barabasi_albert( [&quot;edges_specy&quot;::edge,&quot;vertices_specy&quot;::node,&quot;size&quot;::3,&quot;m&quot;::5] );"/>
<example code="graphEpidemio source_of(edge(3)) &#9;&#9;&#9;&#9;--:  node1"/>
<example code="let graphFromMap type: graph &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);"/>
<example code="graphFromMap source_of(link({1,5}::{12,45}))  &#9;--: {1.0;5.0}"/>
</examples>
<seeAlso>
<see id="source_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="rewire_p" name="rewire_p">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="g" position="0" type="graph"/>
<operand name="probability" position="1" type="float"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Files" id="properties" name="properties">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.file.IGamaFile" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>opens a file that is a kind of properties.</result>
<comment>The file should have a properties extension, cf. type file definition for supported file extensions.</comment>
<specialCases>
<case item="If the specified string does not refer to an existing propserites file, an exception is risen."/>
</specialCases>
<examples>
<example code="let fileT type: file value: properties(&quot;../includes/testProperties.properties&quot;);  // fileT represents the properties file &quot;../includes/testProperties.properties&quot;"/>
</examples>
<seeAlso>
<see id="file"/>
<see id="shapefile"/>
<see id="image"/>
<see id="text"/>
</seeAlso>
</documentation>
</operator>
<operator category="IMatrix" id="column_at" name="column_at">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="java.util.List&lt;T&gt;" type="-13">
<operand name="msi.gama.util.matrix.imatrix&lt;t&gt;" position="0" type="matrix"/>
<operand name="num_line" position="1" type="int"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Queries" id="agents_inside" name="agents_inside">
<alternativeName/>
<combinaisonIO>
<operands contentType="11" returnType="list of points" type="-13">
<operand name="toBeCastedIntoGeometry" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agents covered by the operand (casted as a geometry).</result>
<comment/>
<specialCases/>
<examples>
<example code="agents_inside(self) -&gt; return the agents that are covered by the shape of the agent applying the operator."/>
</examples>
<seeAlso>
<see id="agent_closest_to"/>
<see id="agents_overlapping"/>
<see id="closest_to"/>
<see id="inside"/>
<see id="overlapping"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="asin" name="asin">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>the arcsin of the operand (which has to be expressed in decimal degrees).</result>
<comment/>
<specialCases/>
<examples>
<example code="acos (90) &#8594; 1"/>
</examples>
<seeAlso>
<see id="acos"/>
<see id="atan"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="container" name="container">
<alternativeName/>
<combinaisonIO>
<operands contentType="-16" returnType="container" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a container</result>
<comment/>
<specialCases>
<case item="if the operand is a container, returns itself"/>
<case item="otherwise, returns the operand casted to a list"/>
</specialCases>
<examples/>
<seeAlso>
<see id="list"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="set_verbose" name="set_verbose">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="verbose" position="1" type="bool"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Files" id="file" name="file">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.file.IGamaFile" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>opens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute.</result>
<comment>The file should have a supported extension, see file type deifnition for supported file extensions.</comment>
<specialCases>
<case item="If the specified string does not refer to an existing file, an exception is risen when the variable is used."/>
</specialCases>
<examples>
<example code="let fileT type: file value: file(&quot;../includes/Stupid_Cell.Data&quot;); "/>
<example code="&#9;&#9;&#9;// fileT represents the file &quot;../includes/Stupid_Cell.Data&quot;"/>
<example code="&#9;&#9;&#9;// fileT.contents here contains a matrix storing all the data of the text file"/>
</examples>
<seeAlso>
<see id="folder"/>
<see id="new_folder"/>
</seeAlso>
</documentation>
</operator>
<operator category="Properties" id="touches" name="touches">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).</result>
<comment>returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.</comment>
<specialCases>
<case item="if one of the operand is null, returns false."/>
</specialCases>
<examples>
<example code="polyline([{10,10},{20,20}]) touches geometry({15,15}) -&gt; false"/>
<example code="polyline([{10,10},{20,20}]) touches geometry({10,10}) -&gt; true"/>
<example code="geometry({15,15}) touches geometry({15,15}) -&gt; false"/>
<example code="polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]) -&gt; true"/>
<example code="polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]) -&gt; false"/>
<example code="polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) touches geometry({15,15}) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) touches geometry({10,15}) -&gt; true"/>
</examples>
<seeAlso>
<see id="&lt;-&gt;"/>
<see id="disjoint_from"/>
<see id="crosses"/>
<see id="overlaps"/>
<see id="partially_overlaps"/>
<see id="intersects"/>
</seeAlso>
</documentation>
</operator>
<operator category="Relations" id="path_to" name="path_to">
<alternativeName/>
<documentation>
<result>A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.</result>
<comment/>
<specialCases/>
<examples>
<example code="ag1 path_to ag2 -&gt; the path between ag1 and ag2 considering the topology of the agent applying the operator"/>
</examples>
<seeAlso>
<see id="towards"/>
<see id="direction_to"/>
<see id="distance_between"/>
<see id="direction_between"/>
<see id="path_between"/>
<see id="distance_to"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="path" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="g1" position="1" type="shape"/>
</operands>
<operands contentType="-13" returnType="path" type="-13">
<operand name="g" position="0" type="point"/>
<operand name="g1" position="1" type="point"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Containers" id="of_species" name="of_species">
<alternativeName/>
<combinaisonIO>
<operands contentType="-19" returnType="list" type="-13">
<operand name="agents" position="0" type="container"/>
<operand name="s" position="1" type="species"/>
</operands>
</combinaisonIO>
<documentation>
<result>a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitely if it is to be used in an ask statement, for instance).</result>
<comment/>
<specialCases>
<case item="if the right operand is nil, of_species returns the right operand"/>
</specialCases>
<examples>
<example code="(self neighbours_at 10) of_species (species (self)) &#9;--:  all the neighbouring agents of the same species."/>
<example code="[test(0),test(1),node(1),node(2)] of_species test &#9;&#9;--:  [test0,test1]"/>
<example code="[1,2,3,4,5,6] of_species test&#9;&#9;&#9;&#9;&#9;&#9;&#9;--:&#9; []"/>
</examples>
<seeAlso>
<see id="of_generic_species"/>
</seeAlso>
</documentation>
</operator>
<operator category="IContainer" id="min" name="min">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="ValueType" type="-16">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>the minimum element found in the operand.</result>
<comment>the min operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list of int or float: min returns the minimum of all the elements"/>
<case item="if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )"/>
<case item="if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them"/>
<case item="if it is a map, min returns the minimum among the list of all elements value"/>
<case item="if it is a file, min returns the minimum of the content of the file (that is also a container)"/>
<case item="if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)"/>
<case item="if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)"/>
<case item="if it is a matrix of geometry, min returns the minimum of the list of the geometries"/>
<case item="if it is a matrix of another type, min returns the minimum of the elements transformed into float"/>
</specialCases>
<examples>
<example code="min ([100, 23.2, 34.5]) &#9;--: &#9;23.2"/>
</examples>
<seeAlso>
<see id="max"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="reverse" name="reverse">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="string" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
<operands contentType="-16" returnType="container" type="-14">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>the operand elements in the reversed order in a copy of the operand.</result>
<comment>the reverse operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a string, reverse returns a new string with caracters in the reversed order"/>
<case item="if it is a list, reverse returns a copy of the operand list with elements in the reversed order"/>
<case item="if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)"/>
<case item="if it is a file, reverse returns a copy of the file with a reversed content"/>
<case item="if it is a population, reverse returns a copy of the population with elements in the reversed order"/>
<case item="if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed"/>
<case item="if it is a matrix, reverse returns a new matrix containing the transpose of the operand."/>
</specialCases>
<examples>
<example code="reverse ('abcd') &#9;&#9;--: &#9;'dcba';"/>
<example code="reverse ([10,12,14]) &#9;&#9;&#9;&#9;--: &#9;[14, 12, 10]"/>
<example code="reverse ([k1::44, k2::32, k3::12]) --: &#9;[12::k3,  32::k2, 44::k1]"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Graphs" id="weight_of" name="weight_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="edge" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.</result>
<comment>In a localized graph, an edge has a weight by default (the distance between both vertices).</comment>
<specialCases>
<case item="if the left-operand (the graph) is nil, returns nil"/>
<case item="if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight"/>
<case item="if the right-hand operand is neither a node, nor an edge, returns 1."/>
</specialCases>
<examples>
<example code="let graphFromMap type: graph &lt;-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);"/>
<example code="graphFromMap source_of(link({1,5}::{12,45}))  --: 41.48493702538308"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Containers" id="inter" name="inter">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="list" type="-13">
<operand name="l1" position="0" type="container"/>
<operand name="l" position="1" type="container"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>the intersection of the two operandsA geometry resulting from the intersection between the two geometries</result>
<comment>both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.</comment>
<specialCases>
<case item="if an operand is a graph, it will be transformed into the set of its nodes"/>
<case item="if an operand is a map, it will be transformed into the set of its values"/>
<case item="if an operand is a matrix, it will be transformed into the set of the lines"/>
<case item="returns false if the right-operand is nil"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6] inter [2,4] &#9;&#9;&#9;&#9;--: &#9;[2,4]"/>
<example code="[1,2,3,4,5,6] inter [0,8] &#9;&#9;&#9;&#9;--: &#9;[]"/>
<example code="[1::2, 3::4, 5::6] inter [2,4] &#9;&#9;--: &#9;[2,4]"/>
<example code="[1::2, 3::4, 5::6] inter [1,3] &#9;&#9;--: &#9;[]"/>
<example code="matrix([[1,2,3],[4,5,4]]) inter [3,4] &#9;--: &#9;[4,3]"/>
<example code="square(5) intersects {10,10} -&gt; false"/>
</examples>
<seeAlso>
<see id="remove_duplicates"/>
<see id="union"/>
<see id="+"/>
<see id="-"/>
</seeAlso>
</documentation>
</operator>
<operator category="Relations" id="path_between" name="path_between">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="path" type="-13">
<operand name="graph" position="0" type="topology"/>
<operand name="nodes" position="1" type="msi.gama.util.IContainer&lt;?,msi.gama.metamodel.shape.IShape&gt;"/>
</operands>
</combinaisonIO>
<documentation>
<result>A path between a list of two geometries (geometries, agents or points) considering a topology.</result>
<comment/>
<specialCases/>
<examples>
<example code="my_topology path_between [ag1, ag2] -&gt; A path between ag1 and ag2"/>
</examples>
<seeAlso>
<see id="towards"/>
<see id="direction_to"/>
<see id="distance_between"/>
<see id="direction_between"/>
<see id="path_to"/>
<see id="distance_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="ceil" name="ceil">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="double" type="-13">
<operand name="d" position="0" type="double"/>
</operands>
</combinaisonIO>
<documentation>
<result>maps the operand to the smallest following integer.</result>
<comment>More precisely, ceiling(x) is the smallest integer not less than x.</comment>
<specialCases/>
<examples>
<example code="ceil(3) &#9;&#9;--:  4.0"/>
<example code="ceil(3.5) &#9;&#9;--:  4.0"/>
<example code="ceil(-4.7) &#9;--:  -4.0"/>
</examples>
<seeAlso>
<see id="floor"/>
<see id="round"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="successors_of" name="successors_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="list" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="vertex" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)</result>
<comment/>
<specialCases/>
<examples>
<example code="graphEpidemio successors_of (node(3)) &#9;&#9;--: []"/>
<example code="graphFromMap successors_of node({12,45}) &#9;--: [{34.0;56.0}]"/>
</examples>
<seeAlso>
<see id="predecessors_of"/>
<see id="neighbours_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="with_optimizer_type" name="with_optimizer_type">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="optimizerType" position="1" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Operators" id="add_point" name="add_point">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry resulting from the adding of a right-point (coordinate) to the right-geometry</result>
<comment/>
<specialCases/>
<examples>
<example code="square(5) add_point {10,10} -&gt; returns a hexagon"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Maths" id="acos" name="acos">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the arccos of the operand (which has to be expressed in decimal degrees).</result>
<comment/>
<specialCases/>
<examples>
<example code="acos (90) &#8594; 0"/>
</examples>
<seeAlso>
<see id="asin"/>
<see id="atan"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="ln" name="ln">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="x" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="x" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the natural logarithm (base e) of the operand.</result>
<comment/>
<specialCases>
<case item="an exception is raised if the operand is less than zero."/>
</specialCases>
<examples>
<example code="ln(1) &#9;--:&#9; 0.0"/>
</examples>
<seeAlso>
<see id="exp"/>
</seeAlso>
</documentation>
</operator>
<operator category="GamaFileType" id="is_text" name="is_text">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="f" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>the operator tests whether the operand represents the name of a supported text file</result>
<comment>cf. file type definition for supported (espacially image) file extensions.</comment>
<specialCases/>
<examples>
<example code="is_text(&quot;../includes/Stupid_Cell.Data&quot;)    --:  true;"/>
<example code="is_text(&quot;../includes/test.png&quot;)            --:  false;"/>
<example code="is_text(&quot;../includes/test.properties&quot;)     --:  false;"/>
<example code="is_text(&quot;../includes/test.shp&quot;)            --:  false;"/>
</examples>
<seeAlso>
<see id="text"/>
<see id="is_properties"/>
<see id="is_shape"/>
<see id="is_image"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="with_weights" name="with_weights">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="weights" position="1" type="map"/>
</operands>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="weights" position="1" type="list"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Operators" id="split_at" name="split_at">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.GamaList&lt;msi.gama.metamodel.shape.IShape&gt;" type="-13">
<operand name="geom" position="0" type="shape"/>
<operand name="pt" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>The two part of the left-operand lines split at the given right-operand point</result>
<comment/>
<specialCases>
<case item="if the left-operand is a point or a polygon, returns an empty list"/>
</specialCases>
<examples>
<example code="polyline([{1,2},{4,6}]) split_at {7,6}  -&gt; [polyline([{1.0;2.0},{7.0;6.0}]), polyline([{7.0;6.0},{4.0;6.0}])]."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Maths" id="tanh" name="tanh">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the hyperbolic tangent of the operand (which has to be expressed in decimal degrees).</result>
<comment/>
<specialCases/>
<examples>
<example code="tanh(0)  &#9;--: 0.0"/>
<example code="tanh(1)  &#9;--: 0.7615941559557649"/>
<example code="tanh(10) &#9;--: 0.9999999958776927"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Graphs" id="as_edge_graph" name="as_edge_graph">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="edges" position="0" type="container"/>
</operands>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="edges" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>creates a graph from the list/map of edges given as operand</result>
<comment/>
<specialCases>
<case item="if the operand is a list, the graph will be built with elements of the list as vertices"/>
<case item="if the operand is a map, the graph will be built by creating edges from pairs of the map"/>
</specialCases>
<examples>
<example code="as_edge_graph([{1,5},{12,45},{34,56}])  --:  build a graph with these three vertices and reflexive links on each vertices"/>
<example code="as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}])  --:  build a graph with these three vertices and two edges"/>
</examples>
<seeAlso>
<see id=" as_intersection_graph, as_distance_graph"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="simplification" name="simplification">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="distanceTolerance" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.</result>
<comment>The algorithm used for the simplification is Douglas-Peucker</comment>
<specialCases/>
<examples>
<example code="self simplification 0.1 -&gt; returns the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Maths" id="fact" name="fact">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="n" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the factorial of the operand.</result>
<comment/>
<specialCases>
<case item="if the operand is less than 0, fact returns 0."/>
</specialCases>
<examples>
<example code="fact (4) &#9;--:&#9; 24"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Graphs" id="rewire_n" name="rewire_n">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="g" position="0" type="graph"/>
<operand name="count" position="1" type="int"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Files" id="read" name="read">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
<operands contentType="-13" returnType="any" type="-13">
<operand name="s" position="0" type="msi.gama.util.file.IGamaFile"/>
</operands>
</combinaisonIO>
<documentation>
<result>marks the file so that only read operations are allowed.</result>
<comment>A file is created by default in read-only mode. The operator write can change the mode.</comment>
<specialCases/>
<examples>
<example code="read(shapefile(&quot;../images/point_eau.shp&quot;))  --:  returns a file in read-only mode representing &quot;../images/point_eau.shp&quot;"/>
</examples>
<seeAlso>
<see id="file"/>
<see id="write"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="count" name="count">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.</comment>
<specialCases>
<case item="if the left-hand operand is nil, count returns 0"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] count (each &gt; 3) &#9;&#9;&#9;&#9;&#9;--: &#9;5"/>
<example code="g2 count (length(g2 out_edges_of each) = 0  ) &#9;&#9;&#9;--: &#9;5&#9;// Number of nodes of graph g2 without any out edge"/>
<example code="(list(node) count (round(node(each).location.x) &gt; 32)  --:  &#9;2 &#9;// Number of agents node with x &gt; 32"/>
<example code="[1::2, 3::4, 5::6] count (each &gt; 4) &#9;&#9;&#9;&#9;&#9;--: &#9;1"/>
</examples>
<seeAlso>
<see id="group_by"/>
</seeAlso>
</documentation>
</operator>
<operator category="Queries" id="overlapping" name="overlapping">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="list of points" type="-13">
<operand name="targets" position="0" type="msi.gama.util.IContainer&lt;?,msi.gama.metamodel.shape.IShape&gt;"/>
<operand name="toBeCastedIntoGeometry" position="1" type="any"/>
</operands>
<operands contentType="-20" returnType="list of points" type="-13">
<operand name="targets" position="0" type="species"/>
<operand name="toBeCastedIntoGeometry" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agents a mong the left-operand list, overlapping the operand (casted as a geometry).</result>
<comment/>
<specialCases>
<case item="if the left-operand is a species, return agents of the specified species."/>
</specialCases>
<examples>
<example code="[ag1, ag2, ag3] overlapping(self) -&gt; return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator."/>
<example code="species1 overlapping(self) -&gt; return the agents of species species1 that overlap the shape of the agent applying the operator."/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="agent_closest_to"/>
<see id="agents_inside"/>
<see id="closest_to"/>
<see id="inside"/>
<see id="agents_overlapping"/>
</seeAlso>
</documentation>
</operator>
<operator category="Queries" id="at_distance" name="at_distance">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="list" type="-13">
<operand name="list" position="0" type="list"/>
<operand name="distance" position="1" type="float"/>
</operands>
<operands contentType="-20" returnType="list" type="-13">
<operand name="species" position="0" type="species"/>
<operand name="distance" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agents among the left-operand list that are located at a distance &lt;= the right operand from the caller agent (in its topology)</result>
<comment/>
<specialCases>
<case item="If the left operand is a species, return agents of the specified species (slightly more efficient than using list(species1), for instance)"/>
</specialCases>
<examples>
<example code="[ag1, ag2, ag3] at_distance 20 -&gt; return the agents of the list located at a distance &lt;= 20 from the caller agent (in the same order)."/>
<example code="species1 at_distance 20 -&gt; return the agents of species1 located at a distance &lt;= 20 from the caller agent."/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="agent_closest_to"/>
<see id="agents_inside"/>
<see id="closest_to"/>
<see id="inside"/>
<see id="overlapping"/>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="agent_closest_to"/>
<see id="agents_inside"/>
<see id="closest_to"/>
<see id="inside"/>
<see id="overlapping"/>
</seeAlso>
</documentation>
</operator>
<operator category="Logic" id=":" name=":">
<alternativeName/>
<combinaisonIO>
<operands contentType="-21" returnType="any" type="-21">
<operand name="a" position="0" type="any"/>
<operand name="b" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result/>
<comment/>
<specialCases/>
<examples/>
<seeAlso>
<see id="?"/>
</seeAlso>
</documentation>
</operator>
<operator category="Properties" id="overlaps" name="overlaps">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).</result>
<comment/>
<specialCases>
<case item="if one of the operand is null, returns false."/>
<case item="if one operand is a point, returns true if the point is included in the geometry"/>
</specialCases>
<examples>
<example code="polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps geometry({25,25}) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]) -&gt; false"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps geometry({15,15}) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -&gt; true"/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]) -&gt; true"/>
</examples>
<seeAlso>
<see id="&lt;-&gt;"/>
<see id="disjoint_from"/>
<see id="crosses"/>
<see id="intersects"/>
<see id="partially_overlaps"/>
<see id="touches"/>
</seeAlso>
</documentation>
</operator>
<operator category="Files" id="write" name="write">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-13">
<operand name="s" position="0" type="msi.gama.util.file.IGamaFile"/>
</operands>
</combinaisonIO>
<documentation>
<result>marks the file so that read and write operations are allowed.</result>
<comment>A file is created by default in read-only mode.</comment>
<specialCases/>
<examples>
<example code="write(shapefile(&quot;../images/point_eau.shp&quot;))   --: returns a file in read-write mode representing &quot;../images/point_eau.shp&quot;"/>
</examples>
<seeAlso>
<see id="file"/>
<see id="read"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="rectangle" name="rectangle">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="p" position="0" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A rectangle geometry which side sizes are given by the operands.</result>
<comment>the centre of the rectangle is by default the location of the current agent in which has been called this operator.</comment>
<specialCases>
<case item="returns nil if the operand is nil."/>
</specialCases>
<examples>
<example code="rectangle({10, 5}) -&gt; returns a geometry as a rectangle with width = 10 and heigh = 5."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="circle"/>
<see id="cone"/>
<see id="line"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polygon"/>
<see id="polyline"/>
<see id="square"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="Files" id="folder" name="folder">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.file.IGamaFile" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>opens an existing repository</result>
<comment/>
<specialCases>
<case item=" If the specified string does not refer to an existing repository, an exception is risen."/>
</specialCases>
<examples>
<example code="let dirT type: file value: folder(&quot;../includes/&quot;);"/>
<example code="&#9;&#9;&#9;&#9;// dirT represents the repository &quot;../includes/&quot;"/>
<example code="&#9;&#9;&#9;&#9;// dirT.contents here contains the list of the names of included files"/>
</examples>
<seeAlso>
<see id="file"/>
<see id="new_folder"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="round" name="round">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="v" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="v" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the rounded value of the operand.</result>
<comment/>
<specialCases>
<case item="if the operand is an int, round returns it"/>
</specialCases>
<examples>
<example code="round (0.51) &#9;--:&#9; 1"/>
<example code="round (100.2) &#9;--: &#9; 100"/>
</examples>
<seeAlso>
<see id="int"/>
<see id="with_precision"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="as_date" name="as_date">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="string" type="-13">
<operand name="time" position="0" type="double"/>
</operands>
<operands contentType="-13" returnType="string" type="-13">
<operand name="time" position="0" type="double"/>
<operand name="pattern" position="1" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Random" id="gauss" name="gauss">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="point" position="0" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.</result>
<comment/>
<specialCases>
<case item="when the operand is a point, it is read as {mean, standardDeviation}"/>
<case item="when standardDeviation value is 0.0, it always returns the mean value"/>
</specialCases>
<examples>
<example code="gauss({0,0.3})  -&gt;  0.22354"/>
<example code="gauss({0,0.3})  -&gt;  -0.1357"/>
</examples>
<seeAlso>
<see id="truncated_gauss"/>
<see id="poisson"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="triangulate" name="triangulate">
<alternativeName/>
<combinaisonIO>
<operands contentType="13" returnType="msi.gama.util.GamaList&lt;msi.gama.metamodel.shape.IShape&gt;" type="-13">
<operand name="g" position="0" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)</result>
<comment/>
<specialCases/>
<examples>
<example code="triangulate(self) -&gt; returns the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Cast" id="float" name="float">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a floating point value.</result>
<comment/>
<specialCases>
<case item="if the operand is numerical value, returns its value as a floating point value;"/>
<case item="if the operand is a string, tries to convert its content to a floating point value;"/>
<case item="if the operand is a boolean, returns 1.0 for true and 0.0 for false;"/>
<case item="otherwise, returns 0.0"/>
</specialCases>
<examples>
<example code="float(7) &#9;&#9;&#9;&#9;--: 7.0"/>
<example code="float(true) &#9;&#9;&#9;--: 1.0"/>
<example code="float({23, 4.0} &#9;&#9;--: 0.0"/>
<example code="float(5::34) &#9;&#9;&#9;--: 0.0"/>
<example code="float(green) &#9;&#9;&#9;--: 0.0"/>
<example code="float([1,5,9,3]) &#9;&#9;--: 0.0"/>
<example code="float(node1)&#9;&#9;&#9;--: 0.0"/>
<example code="int('4')&#9;&#9;&#9;&#9;--: 4.0"/>
<example code="int('4.7')&#9;&#9;&#9;&#9;--: 4.7 "/>
</examples>
<seeAlso>
<see id="int"/>
</seeAlso>
</documentation>
</operator>
<operator category="Files" id="text" name="text">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.file.IGamaFile" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>opens a file that a is a kind of text.</result>
<comment>The file should have a text extension, cf. file type definition for supported file extensions.</comment>
<specialCases>
<case item="If the specified string does not refer to an existing text file, an exception is risen."/>
</specialCases>
<examples>
<example code="let fileT type: file value: text(&quot;../includes/Stupid_Cell.Data&quot;);"/>
<example code="&#9;&#9;&#9;&#9;// fileT represents the text file &quot;../includes/Stupid_Cell.Data&quot;"/>
</examples>
<seeAlso>
<see id="file"/>
<see id="properties"/>
<see id="image"/>
<see id="shapefile"/>
</seeAlso>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_tlp" name="load_graph_from_tlp">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following TLP file format.</result>
<comment>TLP is the Tulip software graph format.  See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details.The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_tlp( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_TLP_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="IContainer" id="first" name="first">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="ValueType" type="-16">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
<operands contentType="-16" returnType="agent" type="-16">
<operand name="s" position="0" type="species"/>
</operands>
<operands contentType="-13" returnType="string" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>the first element of the operand</result>
<comment>the first operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list, first returns the first element of the list, or nil if the list is empty"/>
<case item="if it is a map, first returns nil (the map do not keep track of the order of elements)"/>
<case item="if it is a file, first returns the first element of the content of the file (that is also a container)"/>
<case item="if it is a population, first returns the first agent of the population"/>
<case item="if it is a graph, first returns the first element in the list of vertexes"/>
<case item="if it is a matrix, first returns the element at {0,0} in the matrix"/>
<case item="for a matrix of int or float, it will return 0 if the matrix is empty"/>
<case item="for a matrix of object or geometry, it will return null if the matrix is empty"/>
<case item="if it is a string, first returns a string composed of its first character"/>
</specialCases>
<examples>
<example code="first ([1, 2, 3]) &#9;&#9;--:   1"/>
<example code="first ({10,12})     &#9;--:   10."/>
<example code="first ('abce')      &#9;--:   'a'"/>
</examples>
<seeAlso>
<see id="last"/>
</seeAlso>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_ncol" name="load_graph_from_ncol">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following ncol file format.</result>
<comment>This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_ncol( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_ncol_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_lgl" name="load_graph_from_lgl">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following LGL file format.</result>
<comment>LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_lgl( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_LGL_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="Logic" id="and" name="and">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="left" position="0" type="bool"/>
<operand name="right" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>a bool value, equal to the logical and between the left-hand operand and the rigth-hand operand.</result>
<comment>both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.</comment>
<specialCases/>
<examples/>
<seeAlso>
<see id="bool"/>
<see id="or"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="with_precision" name="with_precision">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="x" position="0" type="float"/>
<operand name="precision" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>round off the value of left-hand operand to the precision given by the value of right-hand operand</result>
<comment/>
<specialCases/>
<examples>
<example code="12345.78943 with_precision 2 &#9;--:&#9; 12345.79"/>
<example code="123 with_precision 2 &#9;--:&#9; 123.00"/>
</examples>
<seeAlso>
<see id="round"/>
</seeAlso>
</documentation>
</operator>
<operator category="Queries" id="agent_closest_to" name="agent_closest_to">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="agent" type="11">
<operand name="source" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>A agent, the closest to the operand (casted as a geometry).</result>
<comment>the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.</comment>
<specialCases/>
<examples>
<example code="agent_closest_to(self) -&gt; return the closest agent to the agent applying the operator."/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="agents_inside"/>
<see id="agents_overlapping"/>
<see id="closest_to"/>
<see id="inside"/>
<see id="overlapping"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="transformed_by" name="transformed_by">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry resulting from the application of a rotation and a translation (rigth-operand : point {angle(degree), distance} of the left-hand operand (geometry, agent, point)</result>
<comment/>
<specialCases/>
<examples>
<example code="self transformed_by {45, 20} -&gt; returns the geometry resulting from 45 rotation and 10m translation of the geometry of the agent applying the operator."/>
</examples>
<seeAlso>
<see id="rotated_by"/>
<see id="translated_by"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="unknown" name="unknown">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-13">
<operand name="obj" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the operand itself</result>
<comment/>
<specialCases/>
<examples/>
<seeAlso/>
</documentation>
</operator>
<operator category="Cast" id="geometry" name="geometry">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="s" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casts the operand into a geometry</result>
<comment/>
<specialCases>
<case item="if the operand is a point, returns a corresponding geometry point"/>
<case item="if the operand is a agent, returns its geometry"/>
<case item="if the operand is a population, returns the union of each agent geometry"/>
<case item="if the operand is a pair of two agents or geometries, returns the link between the geometry of each element of the operand"/>
<case item="if the operans is a graph, returns the corresponding multi-points geometry"/>
<case item="if the operand is a container of points, if first and the last points are the same, returns the polygon built from these points"/>
<case item="if the operand is a container, returns the union of the geometry of each element"/>
<case item="otherwise, returns nil"/>
</specialCases>
<examples>
<example code="geometry({23, 4.0}) &#9;&#9;&#9;&#9;&#9;--: Point"/>
<example code="geometry(a_graph)&#9;&#9;&#9;&#9;&#9;&#9;--: MultiPoint"/>
<example code="geometry(node1)&#9;&#9;&#9;&#9;&#9;&#9;--: Point"/>
<example code="geometry([{0,0},{1,4},{4,8},{0,0}])&#9;--: Polygon&#9;"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Maths" id="mod" name="mod">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>an int, equal to the remainder of the integer division of the left-hand operand by the rigth-hand operand.</result>
<comment/>
<specialCases>
<case item="if the right-hand operand is equal to zero, raises an exception."/>
</specialCases>
<examples>
<example code="40 mod 3 &#9;&#9;--:  1"/>
<example code="40 mod 4&#9;&#9;--:  0"/>
</examples>
<seeAlso>
<see id="div"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="circle" name="circle">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="radius" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A circle geometry which radius is equal to the operand.</result>
<comment>the centre of the circle is by default the location of the current agent in which has been called this operator.</comment>
<specialCases>
<case item="returns a point if the operand is lower or equal to 0."/>
</specialCases>
<examples>
<example code="circle(10) -&gt; returns a geometry as a circle of radius 10."/>
</examples>
<seeAlso>
<see id="around"/>
<see id="cone"/>
<see id="line"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polygon"/>
<see id="polyline"/>
<see id="rectangle"/>
<see id="square"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="split_with" name="split_with">
<alternativeName>
<altName name="tokenize"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="list" type="-13">
<operand name="target" position="0" type="string"/>
<operand name="pattern" position="1" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Queries" id="neighbours_at" name="neighbours_at">
<alternativeName/>
<documentation>
<result>a list, containing all the agents located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).</result>
<comment>The topology used to compute the neighbourhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.</comment>
<specialCases/>
<examples>
<example code="(self neighbours_at (10)) -&gt; returns all the agents located at a distance lower or equal to 10 to the agent applying the operator."/>
</examples>
<seeAlso>
<see id="neighbours_of"/>
<see id="closest_to"/>
<see id="overlapping"/>
<see id="agents_overlapping"/>
<see id="agents_inside"/>
<see id="agent_closest_to"/>
<see id="at_distance"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="list" type="-13">
<operand name="agent" position="0" type="shape"/>
<operand name="distance" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="list" type="-13">
<operand name="agent" position="0" type="point"/>
<operand name="distance" position="1" type="float"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Containers" id="in" name="in">
<alternativeName/>
<documentation>
<result>true if the right operand contains the left operand, false otherwise</result>
<comment>the definition of in depends on the container</comment>
<specialCases>
<case item="if the right operand is nil or empty, in returns false"/>
</specialCases>
<examples>
<example code="2 in [1,2,3,4,5,6] : true"/>
<example code="7 in [1,2,3,4,5,6] : false"/>
<example code="3 in [1::2, 3::4, 5::6] : true"/>
<example code="6 in [1::2, 3::4, 5::6] : false"/>
</examples>
<seeAlso>
<see id="contains"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="o" position="0" type="any"/>
<operand name="source" position="1" type="container"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="pattern" position="0" type="string"/>
<operand name="target" position="1" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_gexf" name="load_graph_from_gexf">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following GEXF file format.</result>
<comment>GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_gexf( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_Gexf_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="as_time" name="as_time">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="string" type="-13">
<operand name="cycles" position="0" type="double"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Queries" id="agents_at_distance" name="agents_at_distance">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="list" type="-13">
<operand name="distance" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agents situated at a distance &lt;= the right argument.</result>
<comment>Equivalent to neighbours_at with a left-hand argument equal to 'self'</comment>
<specialCases/>
<examples>
<example code="agents_at_distance(20) -&gt; all the agents (excluding the caller) which distance to the caller is &lt;= 20"/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="agent_closest_to"/>
<see id="agents_inside"/>
<see id="closest_to"/>
<see id="inside"/>
<see id="overlapping"/>
<see id="at_distance"/>
</seeAlso>
</documentation>
</operator>
<operator category="Random" id="rnd" name="rnd">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="max" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="max" position="0" type="int"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="max" position="0" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>a random integer in the interval [0, operand]</result>
<comment>to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision</comment>
<specialCases>
<case item="if the operand is a float, it is casted to an int before being evaluated"/>
<case item="if the operand is a point, returns a point with two random integers in the interval [0, operand]"/>
</specialCases>
<examples>
<example code="rnd (2.5) -&gt; 0, 1 or 2"/>
<example code="rnd (2) -&gt; 0, 1 or 2"/>
<example code="rnd (1000) / 1000 -&gt; a float between 0 and 1 with a precision of 0.001"/>
<example code="rnd ({2.5,3}) -&gt; {x,y} with x in [0,2] and y in [0,3]"/>
</examples>
<seeAlso>
<see id="flip"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="exp" name="exp">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns Euler's number e raised to the power of the operand.</result>
<comment/>
<specialCases>
<case item="the operand is casted to a float before being evaluated."/>
</specialCases>
<examples>
<example code="exp (0) &#9;--:&#9; 1"/>
</examples>
<seeAlso>
<see id="ln"/>
</seeAlso>
</documentation>
</operator>
<operator category="Stats" id="harmonic_mean" name="harmonic_mean">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="values" position="0" type="msi.gama.util.GamaList"/>
</operands>
</combinaisonIO>
<documentation>
<result>the harmonic mean of the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Harmonic_mean"&gt;Harmonic_mean&lt;/A&gt; for more details.</result>
<comment>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</comment>
<specialCases/>
<examples>
<example code="&#9;harmonic_mean ([4.5, 3.5, 5.5, 7.0]) -&gt; 4.804159445407279"/>
</examples>
<seeAlso>
<see id="mean"/>
<see id="median"/>
<see id="geometric_mean"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="directed" name="directed">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="g" position="0" type="graph"/>
</operands>
</combinaisonIO>
<documentation>
<result>the operand graph becomes a directed graph.</result>
<comment>the operator alters the operand graph, it does not create a new one.</comment>
<specialCases/>
<examples/>
<seeAlso>
<see id="undirected"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="group_by" name="group_by">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="map" type="-13">
<operand name="original" position="0" type="map"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
<operands contentType="-13" returnType="map" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, group_by returns a new empty map"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] group_by (each &gt; 3) &#9;--: &#9;[false::[1, 2, 3], true::[4, 5, 6, 7, 8]] "/>
<example code="g2 group_by (length(g2 out_edges_of each) ) &#9;--: &#9;[ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]]"/>
<example code="(list(node) group_by (round(node(each).location.x))    --:  [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]]"/>
<example code="[1::2, 3::4, 5::6] group_by (each &gt; 4) &#9;--: &#9;[false::[2, 4], true::[6]]"/>
</examples>
<seeAlso>
<see id="first_with"/>
<see id="last_with"/>
<see id="where"/>
</seeAlso>
</documentation>
</operator>
<operator category="Operators" id="masked_by" name="masked_by">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="source" position="0" type="shape"/>
<operand name="obstacles" position="1" type="msi.gama.util.GamaList&lt;msi.gama.metamodel.agent.IAgent&gt;"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="source" position="0" type="shape"/>
<operand name="targets" position="1" type="species"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry representing the part of the right operand visible from the point of view of the agent using the operator while considering the obstacles defined by the left operand</result>
<comment/>
<specialCases/>
<examples>
<example code="perception_geom masked_by obstacle_list -&gt; returns the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list."/>
<example code="perception_geom masked_by obstacle_species -&gt; returns the geometry representing the part of perception_geom visible from the agent position considering the obstacles of species obstacle_species."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="IMatrix" id="times" name="times">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="matrix" type="-13">
<operand name="msi.gama.util.matrix.imatrix&lt;t&gt;" position="0" type="matrix"/>
<operand name="other" position="1" type="matrix"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Containers" id="collate" name="collate">
<alternativeName/>
<combinaisonIO>
<operands contentType="-16" returnType="list" type="-13">
<operand name="original" position="0" type="list"/>
</operands>
</combinaisonIO>
<documentation>
<result>a new list containing interleaved elements of the operand</result>
<comment>the operand should be a list of lists of elements. The result is a list of elements. </comment>
<specialCases>
<case item="if the operand is nil or a list of (non-list) elements, accumulate returns an empty list"/>
</specialCases>
<examples>
<example code="collate([1,2,4,3,5,7,6,8]) &#9;--: &#9;[]"/>
<example code="collate([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']])  --:  [e11,e21,e31,e12,e22,e32,e13,e23,e33]"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Containers" id="collect" name="collect">
<alternativeName/>
<combinaisonIO>
<operands contentType="-17" returnType="list" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a new list, in which each element is the evaluation of the right-hand operand.</result>
<comment>collect is very similar to accumulate except. Nevertheless if the evaluation of the right-hand operand produces a list,the returned list is a list of list of elements. In contrarily, the list produces by accumulate is only a list of elements (all the lists) produced are concaneted. In addition, collect can be applied to any container.</comment>
<specialCases>
<case item="if the left-hand operand is nil, accumulate returns an empty list"/>
</specialCases>
<examples>
<example code="[1,2,4] collect (each *2)  &#9;--: &#9;[2,4,8]"/>
<example code="[1,2,4] collect ([2,4])  &#9;&#9;--: &#9;[[2,4],[2,4],[2,4]]"/>
<example code="[1::2, 3::4, 5::6] collect (each + 2) --: [8,4,6]"/>
<example code="(list(node) collect (node(each).location.x * 2)    --:  [25.65, 158.99, 140.80, 80.11, 125.47, 37.830, 4.62,...]"/>
</examples>
<seeAlso>
<see id="accumulate"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="graph" name="graph">
<alternativeName/>
<combinaisonIO>
<operands contentType="-16" returnType="graph" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a graph.</result>
<comment/>
<specialCases>
<case item="if the operand is a graph, returns the graph itself"/>
<case item="if the operand is a list, returns a new graph with the elements of the left-hand operand as vertices and no edge. The graph will be spatial is the right-hand operand is true;"/>
<case item="if the operand is a map, "/>
<case item="otherwise, returns nil"/>
</specialCases>
<examples>
<example code="graph([1,5,9,3]) &#9;--: ([1: in[] + out[], 3: in[] + out[], 5: in[] + out[], 9: in[] + out[]], [])"/>
<example code="graph(['a'::345, 'b'::13])  --:  ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)])"/>
<example code="graph(a_graph)&#9;--: a_graph"/>
<example code="graph(node1)&#9;--: null"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Graphs" id="agent_from_geometry" name="agent_from_geometry">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="agent" type="-13">
<operand name="path" position="0" type="path"/>
<operand name="geom" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).</result>
<comment/>
<specialCases>
<case item="if the left-hand operand is nil, returns nil"/>
</specialCases>
<examples>
<example code="let line type: geometry &lt;- one_of(path_followed.segments);"/>
<example code="let ag type: road &lt;- road(path_followed agent_from_geometry line);"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Cast" id="species" name="species">
<alternativeName>
<altName name="species_of"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-15" returnType="species" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a species.</result>
<comment/>
<specialCases>
<case item="if the operand is nil, returns nil;"/>
<case item="if the operand is an agent, returns its species;"/>
<case item="if the operand is a string, returns the species with this name (nil if not found);"/>
<case item="otherwise, returns nil"/>
</specialCases>
<examples>
<example code="species(self)&#9;&#9;&#9;--: species of the current agent"/>
<example code="species('node')&#9;&#9;--: node"/>
<example code="species([1,5,9,3]) &#9;--: null"/>
<example code="species(node1)&#9;&#9;&#9;--: node"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Cast" id="pair" name="pair">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="pair" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a pair value.</result>
<comment/>
<specialCases>
<case item="if the operand is null, returns null;"/>
<case item="if the operand is a point, returns the pair x-coordinate::y-coordinate;"/>
<case item="if the operand is a particular kind of geometry, a link between geometry, returns the pair formed with these two geoemtries;"/>
<case item="if the operand is a map, returns the pair where the first element is the list of all the keys of the map and the second element is the list of all the values of the map;"/>
<case item="if the operand is a list, returns a pair with the two first element of the list used to built the pair"/>
<case item="if the operand is a link, returns a pair source_link::destination_link"/>
<case item="Otherwise, returns the pair string(operand)::operand."/>
</specialCases>
<examples>
<example code="pair(true) &#9;&#9;&#9;&#9;&#9;&#9;&#9;--: true::true"/>
<example code="pair({23, 4.0} &#9;&#9;&#9;&#9;&#9;&#9;--: 23.0::4.0"/>
<example code="pair([1,5,9,3]) &#9;&#9;&#9;&#9;&#9;&#9;--: 1::5"/>
<example code="pair([[3,7],[2,6,9],0]) &#9;&#9;&#9;&#9;--: [3,7]::[2,6,9]"/>
<example code="pair(['a'::345, 'b'::13, 'c'::12])  &#9;--: [b,c,a]::[13,12,345]"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Logic" id="?" name="?">
<alternativeName/>
<combinaisonIO>
<operands contentType="-19" returnType="any" type="-17">
<operand name="left" position="0" type="bool"/>
<operand name="right" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :</result>
<comment>These functional tests can be combined together.</comment>
<specialCases/>
<examples>
<example code="[10, 19, 43, 12, 7, 22] collect ((each &gt; 20) ? 'above' : 'below')    --:  ['below', 'below', 'above', 'below', 'below', 'above']"/>
<example code="set color value:(food &gt; 5) ? 'red' : ((food &gt;= 2)? 'blue' : 'green');"/>
</examples>
<seeAlso>
<see id=":"/>
</seeAlso>
</documentation>
</operator>
<operator category="Files" id="get" name="get">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="s" position="1" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Punctal" id="farthest_point_to" name="farthest_point_to">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="point" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>the farthest point of the left-operand to the left-point.</result>
<comment/>
<specialCases/>
<examples>
<example code="geom farthest_point_to(pt) -&gt; the closest point of geom to pt"/>
</examples>
<seeAlso>
<see id="any_location_in"/>
<see id="any_point_in"/>
<see id="closest_points_with"/>
<see id="points_at"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="map" name="map">
<alternativeName/>
<documentation>
<result>casting of the operand to a map.</result>
<comment/>
<specialCases>
<case item="if the operand is a color RRGGBB, returns a map with the three elements: &quot;r&quot;::RR, &quot;g&quot;::GG, &quot;b&quot;::BB;"/>
<case item="if the operand is a point, returns a map with two elements: &quot;x&quot;:: x-ccordinate and &quot;y&quot;:: y-coordinate;"/>
<case item="if the operand is pair, returns a map with this only element;"/>
<case item="if the operand is a species name, returns the map containing all the agents of the species as a pair nom_agent::agent;"/>
<case item="if the operand is a agent, returns a map containing all the attributes as a pair attribute_name::attribute_value;"/>
<case item="if the operand is a list, returns a map containing either elements of the list if it is a list of pairs, or pairs list.get(i)::list.get(i+1);"/>
<case item="if the operand is a file, returns the content casted to map;"/>
<case item="if the operand is a graph, returns the a map with pairs edge_source::edge_target;"/>
<case item="otherwise returns a map containing only the pair operand::operand."/>
</specialCases>
<examples/>
<seeAlso/>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="map" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
<operands contentType="-13" returnType="java.util.Map" type="-13">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Cast" id="rgb" name="rgb">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a rgb color.</result>
<comment/>
<specialCases>
<case item="if the operand is nil, returns white;"/>
<case item="if the operand is a string, the allowed color names are the constants defined in the java.awt.Color class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow. Otherwise tries to cast the string to an int and returns this color"/>
<case item="if the operand is a list, the integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color;"/>
<case item="if the operand is a map, the red, green, blue components take the value associated to the keys &quot;r&quot;, &quot;g&quot;, &quot;b&quot; in the map;"/>
<case item="if the operand is a matrix, return the color of the matrix casted as a list;"/>
<case item="if the operand is a boolean, returns black for true and white for false;"/>
<case item="if the operand is an integer value, the decimal integer is translated into a hexadecimal value: OxRRGGBB. The red (resp. green, blue) component of the color take the value RR (resp. GG, BB) translated in decimal."/>
</specialCases>
<examples>
<example code="rgb(3.78) &#9;&#9;&#9;--: rgb([0,0,3])"/>
<example code="rgb(true) &#9;&#9;&#9;--: rgb([0,0,0]) //black "/>
<example code="rgb({23, 4.0} &#9;&#9;--: rgb([0,0,0]) //black "/>
<example code="rgb(5::34) &#9;&#9;--: rgb([0,0,0]) //black "/>
<example code="rgb(green) &#9;&#9;--: rgb([0,255,0]) //green "/>
<example code="rgb([1,5,9,3]) &#9;--: rgb([1,5,9])"/>
<example code="rgb(node1)&#9;&#9;&#9;--: rgb([0,0,1])"/>
<example code="rgb('4')&#9;&#9;&#9;--: rgb([0,0,4])"/>
<example code="rgb('4.7')&#9;&#9;&#9;--:  // Exception "/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Queries" id="closest_to" name="closest_to">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-20">
<operand name="targets" position="0" type="msi.gama.util.IContainer&lt;?,msi.gama.metamodel.shape.IShape&gt;"/>
<operand name="source" position="1" type="shape"/>
</operands>
<operands contentType="-13" returnType="agent" type="-20">
<operand name="targets" position="0" type="species"/>
<operand name="source" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>An agent among the left-operand list, the closest to the operand (casted as a geometry).</result>
<comment>the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.</comment>
<specialCases>
<case item="if the left-operand is a species, return an agent of the specified species."/>
</specialCases>
<examples>
<example code="[ag1, ag2, ag3] closest_to(self) -&gt; return the closest agent among ag1, ag2 and ag3 to the agent applying the operator."/>
<example code="neighbours_at"/>
<example code="neighbours_of"/>
<example code="species1 closest_to(self) -&gt; return the closest agent of species species1 to the agent applying the operator."/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="inside"/>
<see id="overlapping"/>
<see id="agents_overlapping"/>
<see id="agents_inside"/>
<see id="agent_closest_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="atan" name="atan">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>the arctan of the operand (which has to be expressed in decimal degrees).</result>
<comment/>
<specialCases/>
<examples>
<example code="atan (45) &#8594; 1"/>
</examples>
<seeAlso>
<see id="acos"/>
<see id="asin"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="rotated_by" name="rotated_by">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="angle" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="angle" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)</result>
<comment>the right-hand operand can be a float or a int</comment>
<specialCases/>
<examples>
<example code="self rotated_by 45 -&gt; returns the geometry resulting from a 45 degres rotation to the geometry of the agent applying the operator."/>
</examples>
<seeAlso>
<see id="transformed_by"/>
<see id="translated_by"/>
</seeAlso>
</documentation>
</operator>
<operator category="Punctal" id="closest_points_with" name="closest_points_with">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="msi.gama.util.IList&lt;msi.gama.metamodel.shape.GamaPoint&gt;" type="-13">
<operand name="a" position="0" type="shape"/>
<operand name="b" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of two closest points between the two geometries.</result>
<comment/>
<specialCases/>
<examples>
<example code="geom1 closest_points_with(geom2) -&gt; [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1"/>
</examples>
<seeAlso>
<see id="any_location_in"/>
<see id="any_point_in"/>
<see id="farthest_point_to"/>
<see id="points_at"/>
</seeAlso>
</documentation>
</operator>
<operator category="Properties" id="crosses" name="crosses">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).</result>
<comment/>
<specialCases>
<case item="if one of the operand is null, returns false."/>
<case item="if one operand is a point, returns false."/>
</specialCases>
<examples>
<example code="polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]) -&gt; true."/>
<example code="polyline([{10,10},{20,20}]) crosses geometry({15,15}) -&gt; false"/>
<example code="polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]) -&gt; true"/>
</examples>
<seeAlso>
<see id="&lt;-&gt;"/>
<see id="disjoint_from"/>
<see id="intersects"/>
<see id="overlaps"/>
<see id="partially_overlaps"/>
<see id="touches"/>
</seeAlso>
</documentation>
</operator>
<operator category="Random" id="one_of" name="one_of">
<alternativeName>
<altName name="any"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="agent" type="-16">
<operand name="l" position="0" type="species"/>
</operands>
<operands contentType="-13" returnType="ValueType" type="-16">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>a random element from the listone of the values stored in this container using GAMA.getRandom()</result>
<comment>the one_of operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if the list is empty, returns nil "/>
<case item="If the operand is a species, the operand is casted to a list before the expression is evaluated. Therefore, if foo is the name of a species, any(foo) will return a random agent from this species (see list)"/>
<case item="if the operand is empty, one_of returns nil"/>
<case item="if it is a list or a matrix, one_of returns one of the elements of the list or of the matrix"/>
<case item="if it is a map, one_of returns one of the values of the map"/>
<case item="if it is a graph, one_of returns one of the nodes of the graph"/>
<case item="if it is a file, one_of returns one of the elements of the content of the file (that is also a container)"/>
<case item="if it is a population, one_of returns one of the agents of the population"/>
</specialCases>
<examples>
<example code="one_of (bug) -&gt; bug3     // The species `bug` has previously be defined"/>
<example code="any ([1,2,3]) &#9;&#9;--: &#9;1, 2, or 3"/>
<example code="one_of ([1,2,3]) &#9;--:&#9; &#9;1, 2, or 3"/>
<example code="one_of ([2::3, 4::5, 6::7]) &#9;--: &#9;3, 5 or 7"/>
<example code="// The species bug has previously been defined"/>
<example code="one_of (bug) &#9;&#9;--:&#9;&#9; bug3"/>
<example code="let mat3 type:matrix value: matrix([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]])"/>
<example code="one_of(mat3) &#9;&#9;--: &#9; &quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;, &quot;c21&quot;,&quot;c22&quot; or &quot;c23&quot;"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Containers" id="index_of" name="index_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="l1" position="0" type="list"/>
<operand name="o" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="any" type="-13">
<operand name="m" position="0" type="map"/>
<operand name="o" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="target" position="0" type="string"/>
<operand name="pattern" position="1" type="string"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="m" position="0" type="matrix"/>
<operand name="o" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>the index of the first occurence of the right operand in the left operand container</result>
<comment>index_of is only defined for list, map and matrix. The definition of index_of and the type of the index depend on the container</comment>
<specialCases>
<case item="if the left operand is a list, index_of returns the index as an integer"/>
<case item="if the left operand is a map, index_of returns the index as a pair"/>
<case item="if the left operand is a matrix, index_of returns the index as a point"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6] index_of 4 &#9;--: &#9;3"/>
<example code="[4,2,3,4,5,4] index_of 4  &#9;--: &#9;0"/>
<example code="[1::2, 3::4, 5::6] index_of 4 &#9;&#9;--: &#9;3::4"/>
<example code="matrix([[1,2,3],[4,5,6]]) index_of 4  &#9;--: &#9;{1.0;0.0}"/>
</examples>
<seeAlso>
<see id="at"/>
<see id="last_index_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="contains_any" name="contains_any">
<alternativeName/>
<documentation>
<result>true if the left operand contains one of the elements of the right operand, false otherwise</result>
<comment>the definition of contains depends on the container</comment>
<specialCases>
<case item="if the right operand is nil or empty, contains_any returns false"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6] contains_any [2,4] &#9;&#9;--: &#9;true "/>
<example code="[1,2,3,4,5,6] contains_any [2,8] &#9;&#9;--: &#9;true"/>
<example code="[1::2, 3::4, 5::6] contains_any [1,3] &#9;--: &#9;true "/>
<example code="[1::2, 3::4, 5::6] contains_any [2,4] &#9;--: &#9;false"/>
</examples>
<seeAlso>
<see id="contains"/>
<see id="contains_all"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="m" position="0" type="container"/>
<operand name="l" position="1" type="container"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="target" position="0" type="string"/>
<operand name="l" position="1" type="java.util.List"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Logic" id="!" name="!">
<alternativeName>
<altName name="not"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="b" position="0" type="bool"/>
</operands>
</combinaisonIO>
<documentation>
<result>opposite boolean value.</result>
<comment/>
<specialCases>
<case item="if the parameter is not boolean, it is casted to a boolean value."/>
</specialCases>
<examples>
<example code="! (true) &#9;&#9;--:&#9; &#9;false"/>
</examples>
<seeAlso>
<see id="bool"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="contains_all" name="contains_all">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="target" position="0" type="string"/>
<operand name="l" position="1" type="java.util.List"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="m" position="0" type="container"/>
<operand name="l" position="1" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if the left operand contains all the elements of the right operand, false otherwise</result>
<comment>the definition of contains depends on the container</comment>
<specialCases>
<case item="if the right operand is nil or empty, contains_all returns true"/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6] contains_all [2,4] &#9;&#9;--: &#9;true "/>
<example code="[1,2,3,4,5,6] contains_all [2,8] &#9;&#9;--: &#9;false"/>
<example code="[1::2, 3::4, 5::6] contains_all [1,3] &#9;--: &#9;true "/>
<example code="[1::2, 3::4, 5::6] contains_all [2,4] &#9;--: &#9;false"/>
</examples>
<seeAlso>
<see id="contains"/>
<see id="contains_any"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="out_edges_of" name="out_edges_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="list" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="vertex" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.</result>
<comment/>
<specialCases/>
<examples>
<example code="graphEpidemio out_edges_of (node(3))   --:   []"/>
<example code="graphFromMap out_edges_of {12,45}      --: [LineString]"/>
</examples>
<seeAlso>
<see id="in_edges_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="int" name="int">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to an integer value.</result>
<comment/>
<specialCases>
<case item="if the operand is a float, returns its value truncated (but not rounded);"/>
<case item="if the operand is an agent, returns its unique index;"/>
<case item="if the operand is a string, tries to convert its content to an integer value;"/>
<case item="if the operand is a boolean, returns 1 for true and 0 for false;"/>
<case item="if the operand is a color, returns its RGB value as an integer;"/>
<case item="otherwise, returns 0"/>
</specialCases>
<examples>
<example code="int(3.78) &#9;&#9;&#9;--: 3"/>
<example code="int(true) &#9;&#9;&#9;--: 1"/>
<example code="int({23, 4.0} &#9;&#9;--: 0"/>
<example code="int(5::34) &#9;&#9;--: 0"/>
<example code="int(green) &#9;&#9;--: -16711936"/>
<example code="int([1,5,9,3]) &#9;--: 0"/>
<example code="int(node1)&#9;&#9;&#9;--: 1"/>
<example code="int('4')&#9;&#9;&#9;--: 4"/>
<example code="int('4.7')&#9;&#9;&#9;--:  // Exception "/>
</examples>
<seeAlso>
<see id="round"/>
<see id="float"/>
</seeAlso>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="generate_watts_strogatz" name="generate_watts_strogatz">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a random small-world network (following Watts-Strogatz model).</result>
<comment>The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
<case item="&quot;size&quot;: the graph will contain (size + 1) nodes. Size must be greater than k."/>
<case item="&quot;p&quot;: probability to &quot;rewire&quot; an edge. So it must be between 0 and 1. The parameter is often called beta in the literature."/>
<case item="&quot;k&quot;: the base degree of each node. k must be greater than 2 and even."/>
</specialCases>
<examples>
<example code="let graphWatts type: graph &lt;- generate_watts_strogatz( [&quot;"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edge,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::node,"/>
<example code="&#9;&#9;&#9;&quot;size&quot;::2,"/>
<example code="&#9;&#9;&#9;&quot;p&quot;::0.3,"/>
<example code="&#9;&#9;&#9;&quot;k&quot;::0] );"/>
</examples>
<seeAlso>
<see id="generate_barabasi_albert"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="at" name="at">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="string" type="-13">
<operand name="lv" position="0" type="string"/>
<operand name="rv" position="1" type="int"/>
</operands>
<operands contentType="-20" returnType="agent" type="-13">
<operand name="s" position="0" type="species"/>
<operand name="val" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="ValueType" type="-20">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
<operand name="index" position="1" type="KeyType"/>
</operands>
<operands contentType="-20" returnType="agent" type="-13">
<operand name="s" position="0" type="species"/>
<operand name="val" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the element at the right operand index of the container</result>
<comment>The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list or a matrix, at returns the element at the index specified by the right operand"/>
<case item="if it is a map, at returns the value corresponding the right operand as key. If the right operand is not a key of the map, at returns nil"/>
<case item="if it is a file, at returns the element of the file content at the index specified by the right operand"/>
<case item="if it is a population, at returns the agent at the index specified by the right operand"/>
<case item="if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node"/>
<case item="if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge"/>
<case item="if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph"/>
</specialCases>
<examples>
<example code="[1, 2, 3] at 2&#9;--:    2 "/>
<example code="[{1,2}, {3,4}, {5,6}] contains {3,4}     --:   true"/>
</examples>
<seeAlso>
<see id="contains_all, contains_any"/>
</seeAlso>
</documentation>
</operator>
<operator category="Creation" id="around" name="around">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="width" position="0" type="float"/>
<operand name="toBeCastedIntoGeometry" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.</result>
<comment/>
<specialCases>
<case item="returns a circle geometry of radius right-operand if the left-operand is nil"/>
</specialCases>
<examples>
<example code="10 around circle(5) -&gt; returns a the ring geometry between 5 and 10."/>
</examples>
<seeAlso>
<see id="circle"/>
<see id="cone"/>
<see id="line"/>
<see id="link"/>
<see id="norm"/>
<see id="point"/>
<see id="polygon"/>
<see id="polyline"/>
<see id="rectangle"/>
<see id="square"/>
<see id="triangle"/>
</seeAlso>
</documentation>
</operator>
<operator category="IContainer" id="contains" name="contains">
<alternativeName/>
<documentation>
<result>true, if the container contains the right operand, false otherwise</result>
<comment>the contains operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list or a matrix, contains returns true if the list or matrix contains the right operand"/>
<case item="if it is a map, contains returns true if the operand is a key of the map"/>
<case item="if it is a file, contains returns true it the operand is contained in the file content"/>
<case item="if it is a population, contains returns true if the operand is an agent of the population, false otherwise"/>
<case item="if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise"/>
</specialCases>
<examples>
<example code="[1, 2, 3] contains 2&#9;--:   true"/>
<example code="[{1,2}, {3,4}, {5,6}] contains {3,4}     --:   true"/>
</examples>
<seeAlso>
<see id="contains_all, contains_any"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="boolean" type="-13">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
<operand name="o" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="target" position="0" type="string"/>
<operand name="pattern" position="1" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Containers" id="sort_by" name="sort_by">
<alternativeName>
<altName name="sort"/>
</alternativeName>
<documentation>
<result>a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them. </result>
<comment>the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.</comment>
<specialCases>
<case item="if the left-hand operand is nil, sort_by returns  nil"/>
</specialCases>
<examples>
<example code="[1,2,4,3,5,7,6,8] sort_by (each) &#9;&#9;&#9;&#9;&#9;--: &#9;[1,2,3,4,5,6,7,8]"/>
<example code="g2 sort_by (length(g2 out_edges_of each) ) &#9;&#9;--: &#9;[node9, node7, node10, node8, node11, node6, node5, node4]"/>
<example code="(list(node) sort_by (round(node(each).location.x)) --:  &#9;[node5, node1, node0, node2, node3]"/>
<example code="[1::2, 3::4, 5::6] sort_by (each) &#9;&#9;&#9;&#9;--: &#9;"/>
</examples>
<seeAlso>
<see id="group_by"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-20" returnType="list" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
<operands contentType="-20" returnType="map" type="-13">
<operand name="original" position="0" type="map"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Colors" id="/" name="/">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="c" position="0" type="rgb"/>
<operand name="i" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p" position="0" type="point"/>
<operand name="d" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="c" position="0" type="rgb"/>
<operand name="i" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p" position="0" type="point"/>
<operand name="d" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.a new color resulting from the division of each component of the color by the right operanda float, equal to the division of the left-hand operand by the rigth-hand operand.</result>
<comment/>
<specialCases>
<case item="if the right-hand operand is equal to zero, raises a &quot;Division by zero&quot; exception"/>
<case item="if the left-hand operator is a point and the right-hand a number, returns a point with coordinates divided by the number"/>
</specialCases>
<examples>
<example code="rgb([255, 128, 32]) / 2.5 &#9;:--  &#9;rgb([102,51,13])"/>
<example code="rgb([255, 128, 32]) / 2 &#9;:--  &#9;rgb([127,64,16])"/>
<example code=""/>
<example code=""/>
<example code="{2,5} / 4&#9;--:  {0.5;1.25}"/>
</examples>
<seeAlso>
<see id="*"/>
</seeAlso>
</documentation>
</operator>
<operator category="Random" id="binomial" name="binomial">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="point" position="0" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A value from a random variable following a binomial distribution. The operand {n,p} represents the number of experiments n and the success probability p.</result>
<comment>The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.</comment>
<specialCases/>
<examples>
<example code="binomial({15,0.6})  -&gt;  a random positive integer"/>
</examples>
<seeAlso>
<see id="poisson"/>
<see id="gauss"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="split_lines" name="split_lines">
<alternativeName/>
<combinaisonIO>
<operands contentType="13" returnType="msi.gama.util.IList&lt;msi.gama.metamodel.shape.IShape&gt;" type="-13">
<operand name="geoms" position="0" type="list"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of geometries resulting after cutting the lines at their intersections.</result>
<comment/>
<specialCases/>
<examples>
<example code="split_lines([line([{0,10}, {20,10}], line([{0,10}, {20,10}]]) -&gt; returns a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])."/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Maths" id="abs" name="abs">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the absolute value of the operand (so a positive int or float depending on the type of the operand).</result>
<comment/>
<specialCases/>
<examples>
<example code="abs (200 * -1 + 0.5) &#8594; 200.5"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="IContainer" id="max" name="max">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="ValueType" type="-16">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>the maximum element found in the operand</result>
<comment>the max operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list of int of float, max returns the maximum of all the elements"/>
<case item="if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )"/>
<case item="if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them"/>
<case item="if it is a map, max returns the maximum among the list of all elements value"/>
<case item="if it is a file, max returns the maximum of the content of the file (that is also a container)"/>
<case item="if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)"/>
<case item="if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)"/>
<case item="if it is a matrix of geometry, max returns the maximum of the list of the geometries"/>
<case item="if it is a matrix of another type, max returns the maximum of the elements transformed into float"/>
</specialCases>
<examples>
<example code="max ([100, 23.2, 34.5]) &#9;--: &#9;100.0"/>
<example code="max([{1.0;3.0},{3.0;5.0},{9.0;1.0},{7.0;8.0}]) &#9;--:  {9.0;1.0}"/>
</examples>
<seeAlso>
<see id="min"/>
</seeAlso>
</documentation>
</operator>
<operator category="IContainer" id="last" name="last">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="ValueType" type="-16">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
<operands contentType="-13" returnType="string" type="-13">
<operand name="s" position="0" type="string"/>
</operands>
<operands contentType="-16" returnType="agent" type="-16">
<operand name="s" position="0" type="species"/>
</operands>
</combinaisonIO>
<documentation>
<result>the last element of the operand</result>
<comment>the last operator behavior depends on the nature of the operand</comment>
<specialCases>
<case item="if it is a list, last returns the last element of the list, or nil if the list is empty"/>
<case item="if it is a map, last returns nil (the map do not keep track of the order of elements)"/>
<case item="if it is a file, last returns the last element of the content of the file (that is also a container)"/>
<case item="if it is a population, last returns the last agent of the population"/>
<case item="if it is a graph, last returns the last element in the list of vertexes"/>
<case item="if it is a matrix, last returns the element at {length-1,length-1} in the matrix"/>
<case item="for a matrix of int or float, it will return 0 if the matrix is empty"/>
<case item="for a matrix of object or geometry, it will return null if the matrix is empty"/>
<case item="if it is a string, last returns a string composed of its last character, or an empty string if the operand is empty"/>
</specialCases>
<examples>
<example code="last ({10,12}) &#9;--:   12"/>
<example code="last ([1, 2, 3]) &#9;--:   3."/>
<example code="last ('abce') &#9;&#9;--:   'e'"/>
</examples>
<seeAlso>
<see id="first"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="undirected" name="undirected">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="g" position="0" type="graph"/>
</operands>
</combinaisonIO>
<documentation>
<result>the operand graph becomes an undirected graph.</result>
<comment>the operator alters the operand graph, it does not create a new one.</comment>
<specialCases/>
<examples/>
<seeAlso>
<see id="directed"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="is" name="is">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="any"/>
<operand name="b" position="1" type="any expression"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Maths" id="^" name="^">
<alternativeName>
<altName name="**"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>the left-hand operand raised to the power of the right-hand operand.</result>
<comment/>
<specialCases>
<case item="if the right-hand operand is equal to 0, returns 1"/>
<case item="if it is equal to 1, returns the left-hand operand."/>
</specialCases>
<examples>
<example code=""/>
<example code=""/>
</examples>
<seeAlso>
<see id="*"/>
<see id="sqrt"/>
</seeAlso>
</documentation>
</operator>
<operator category="Operators" id="union" name="union">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="elements" position="0" type="msi.gama.util.GamaList"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="target" position="0" type="species"/>
</operands>
<operands contentType="-20" returnType="list" type="-13">
<operand name="l1" position="0" type="list"/>
<operand name="l" position="1" type="list"/>
</operands>
</combinaisonIO>
<documentation>
<result>The geometry resulting from the union of all geometries of agents of the operand-speciesreturns a new list containing all the elements of both operands without duplicated elements. Elements of this new list are sorted.</result>
<comment>union is only defined with a list as left operand</comment>
<specialCases>
<case item="if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the union all the geometries"/>
<case item="if the right operand is nil, union returns a copy of the left operand"/>
</specialCases>
<examples>
<example code="union([geom1, geom2, geom3]) -&gt; a geometry corresponding to union between geom1, geom2 and geom3"/>
<example code="union(species1)  -&gt; returns the geometry resulting from the union of all of the geometries of agents of species species1."/>
<example code="[1,2,3,4,5,6] union [2,4,9] &#9;&#9;--: &#9;[1,2,3,4,5,6,9]"/>
<example code="[1,2,3,4,5,6] union [0,8] &#9;&#9;&#9;--: &#9;[0,1,2,3,4,5,6,8]"/>
<example code="[1,3,2,4,5,6,8,5,6] union [0,8] &#9;--: &#9;[0,1,2,3,4,5,6,8]"/>
</examples>
<seeAlso>
<see id="inter"/>
<see id="+"/>
</seeAlso>
</documentation>
</operator>
<operator category="Statistics" id="simple_clustering_by_envelope_distance" name="simple_clustering_by_envelope_distance">
<alternativeName/>
<combinaisonIO>
<operands contentType="5" returnType="list" type="-13">
<operand name="agents" position="0" type="list of points"/>
<operand name="distance" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agent groups clustered by distance (considering the agent envelop) considering a distance min between two groups.</result>
<comment>use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.</comment>
<specialCases/>
<examples>
<example code="[ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0 -&gt; for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]"/>
</examples>
<seeAlso>
<see id="simple_clustering_by_distance"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="string" name="string">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="string" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>casting of the operand to a string.</result>
<comment/>
<specialCases>
<case item="if the operand is nil, returns 'nil';"/>
<case item="if the operand is an agent, returns its name;"/>
<case item="if the operand is a string, returns the operand;"/>
<case item="if the operand is an int or a float, returns their string representation (as in Java);"/>
<case item="if the operand is a boolean, returns 'true' or 'false';"/>
<case item="if the operand is a species, returns its name;"/>
<case item="if the operand is a color, returns its litteral value if it has been created with one (i.e. 'black', 'green', etc.) or the string representation of its hexadecimal value."/>
<case item="if the operand is a container, returns its string representation."/>
</specialCases>
<examples>
<example code="string(0) &#9;&#9;&#9;--: 0"/>
<example code="string({23, 4.0} &#9;--: {23.0;4.0}"/>
<example code="string(5::34) &#9;&#9;--: 5::34"/>
<example code="string(['a'::345, 'b'::13, 'c'::12])  --:  b,13; c,12; a,345;"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Comparison" id="&gt;" name="&gt;">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="string"/>
<operand name="b" position="1" type="string"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if the left-hand operand is greater than the right-hand operand, false otherwise.</result>
<comment/>
<specialCases>
<case item="if one of the operands is nil, returns false"/>
<case item="if the operands are strings, a lexicographic comparison is performed"/>
<case item="if both operands are points, returns true if only if left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one."/>
</specialCases>
<examples>
<example code="3.5 &gt; 7  --: false"/>
<example code="3 &gt; 7  --:  false"/>
<example code="3.5 &gt; 7.6  --: false"/>
<example code="abc &gt; aeb  --: false"/>
<example code="{5,7} &gt; {4,6}  --: true"/>
<example code="{5,7} &gt; {4,8}  --: false"/>
<example code="3 &gt; 2.5  --: true"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Containers" id="::" name="::">
<alternativeName/>
<combinaisonIO>
<operands contentType="-17" returnType="pair" type="9">
<operand name="a" position="0" type="any"/>
<operand name="b" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>produces a new pair combining the left and the right operands</result>
<comment/>
<specialCases/>
<examples/>
<seeAlso/>
</documentation>
</operator>
<operator category="Maths" id="tan" name="tan">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="v" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="v" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the trigonometic tangent of the operand (in decimal degrees).</result>
<comment/>
<specialCases>
<case item="the argument is casted to an int before being evaluated. Integers outside the range [0-359] are normalized."/>
</specialCases>
<examples>
<example code="cos (180) &#8594; 0"/>
</examples>
<seeAlso>
<see id="cos"/>
<see id="sin"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="sin" name="sin">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>the sinus of the operand (in decimal degrees).</result>
<comment/>
<specialCases>
<case item="the argument is casted to an int before being evaluated. Integers outside the range [0-359] are normalized."/>
</specialCases>
<examples>
<example code="cos (0) &#8594; 0"/>
</examples>
<seeAlso>
<see id="cos"/>
<see id="tan"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="sqrt" name="sqrt">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="v" position="0" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="v" position="0" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns the square root of the operand.</result>
<comment/>
<specialCases>
<case item="if the operand is negative, an exception is raised"/>
</specialCases>
<examples>
<example code="sqrt(4) &#9;--:&#9; 2.0"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Stats" id="mean" name="mean">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-16">
<operand name="l" position="0" type="container"/>
</operands>
</combinaisonIO>
<documentation>
<result>the mean of all the elements of the operand</result>
<comment>the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.</comment>
<specialCases>
<case item="if the container contains points, the result will be a point"/>
</specialCases>
<examples>
<example code="mean ([4.5, 3.5, 5.5, 7.0]) -&gt; 5.125 "/>
</examples>
<seeAlso>
<see id="sum"/>
</seeAlso>
</documentation>
</operator>
<operator category="Stats" id="median" name="median">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="values" position="0" type="msi.gama.util.GamaList"/>
</operands>
</combinaisonIO>
<documentation>
<result>the median of all the elements of the operand.</result>
<comment>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</comment>
<specialCases/>
<examples>
<example code="median ([4.5, 3.5, 5.5, 7.0]) -&gt; 5.0"/>
</examples>
<seeAlso>
<see id="mean"/>
</seeAlso>
</documentation>
</operator>
<operator category="Queries" id="neighbours_of" name="neighbours_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="11" returnType="list" type="-13">
<operand name="t" position="0" type="topology"/>
<operand name="agent" position="1" type="agent"/>
</operands>
<operands contentType="-13" returnType="list" type="-13">
<operand name="graph" position="0" type="graph"/>
<operand name="vertex" position="1" type="any"/>
</operands>
<operands contentType="11" returnType="list" type="-13">
<operand name="t" position="0" type="topology"/>
<operand name="pair" position="1" type="pair"/>
</operands>
</combinaisonIO>
<documentation>
<result>a list, containing all the agents located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.returns the list of neighbours of the given vertex (right-hand operand) in the given graph (left-hand operand)</result>
<comment/>
<specialCases>
<case item="a list, containing all the agents located at a distance inferior or equal to the right member (float) of the pair (right-hand operand) to the left member (agent, geometry or point) considering the left-hand operand topology."/>
</specialCases>
<examples>
<example code="topology(self) neighbours_of self -&gt; returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology."/>
<example code="graphEpidemio neighbours_of (node(3)) &#9;&#9;--:&#9;[node0,node2]"/>
<example code="graphFromMap neighbours_of node({12,45}) &#9;--: [{1.0;5.0},{34.0;56.0}]"/>
<example code="topology(self) neighbours_of self::10-&gt; returns all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology."/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="closest_to"/>
<see id="overlapping"/>
<see id="agents_overlapping"/>
<see id="agents_inside"/>
<see id="agent_closest_to"/>
<see id="predecessors_of"/>
<see id="successors_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="matrix" name="matrix">
<alternativeName/>
<documentation>
<result>casts the operand into a matrix</result>
<comment/>
<specialCases>
<case item="if the operand is a file, returns its content casted as a matrix"/>
<case item="if the operand is a map, returns a 2-columns matrix with keyx in the first one and value in the second one;"/>
<case item="if the operand is a list, returns a 1-row matrix. Notice that each element of the list should be a single element or lists with the same length;"/>
<case item="if the operand is a graph, returns nil;"/>
<case item="otherwise, returns a 1x1 matrix with the operand at the (0,0) position."/>
</specialCases>
<examples/>
<seeAlso>
<see id="as_matrix"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-16" returnType="matrix" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
<operands contentType="-22" returnType="matrix" type="-13">
<operand name="val" position="0" type="list"/>
</operands>
<operands contentType="-16" returnType="matrix" type="-13">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Containers" id="grid_at" name="grid_at">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="agent" type="-13">
<operand name="s" position="0" type="species"/>
<operand name="val" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result/>
<comment/>
<specialCases/>
<examples/>
<seeAlso/>
</documentation>
</operator>
<operator category="Containers" id="as_map" name="as_map">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="map" type="-13">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand</result>
<comment>the right-hand operand should be pair or a map.</comment>
<specialCases>
<case item="if the left-hand operand is nil or empty, as_map returns a new empty map."/>
</specialCases>
<examples>
<example code="[1,2,3,4,5,6,7,8] as_map (each::(each * 2) &#9;--: &#9;[1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16]"/>
<example code="[1::2,3::4,5::6] as_map (each::(each * 2))&#9;&#9;--: &#9;[2::4, 4::8, 6::12] "/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Statistics" id="simple_clustering_by_distance" name="simple_clustering_by_distance">
<alternativeName/>
<combinaisonIO>
<operands contentType="5" returnType="list" type="-13">
<operand name="agents" position="0" type="list of points"/>
<operand name="distance" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agent groups clustered by distance considering a distance min between two groups.</result>
<comment>use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.</comment>
<specialCases/>
<examples>
<example code="[ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0 -&gt; for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]"/>
</examples>
<seeAlso>
<see id="simple_clustering_by_envelope_distance"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="div" name="div">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>an int, equal to the truncation of the division of the left-hand operand by the rigth-hand operand.</result>
<comment/>
<specialCases>
<case item="if the right-hand operand is equal to zero, raises an exception."/>
</specialCases>
<examples>
<example code="40 div 3 &#9;--:  13"/>
<example code="40 div 4.1&#9;&#9;--:  9"/>
</examples>
<seeAlso>
<see id="mod"/>
</seeAlso>
</documentation>
</operator>
<operator category="System" id="eval_gaml" name="eval_gaml">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-13">
<operand name="gaml" position="0" type="string"/>
</operands>
</combinaisonIO>
</operator>
<operator category="GraphsGraphstream" id="generate_barabasi_albert" name="generate_barabasi_albert">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a random scale-free network (following Barabasi&#8211;Albert (BA) model).</result>
<comment>The Barabasi&#8211;Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
<case item="&quot;size&quot;: the graph will contain (size + 1) nodes"/>
<case item="&quot;m&quot;: the number of edges added per novel node"/>
</specialCases>
<examples>
<example code="let graphEpidemio type: graph &lt;- generate_barabasi_albert( ["/>
<example code="&#9;&#9;&quot;edges_specy&quot;::edge,"/>
<example code="&#9;&#9;&quot;vertices_specy&quot;::node,"/>
<example code="&#9;&#9;&quot;size&quot;::3,"/>
<example code="&#9;&#9;&quot;m&quot;::5] );"/>
</examples>
<seeAlso>
<see id="generate_watts_strogatz"/>
</seeAlso>
</documentation>
</operator>
<operator category="Transformations" id="+" name="+">
<alternativeName>
<altName name="buffer"/>
<altName name="enlarged_by"/>
</alternativeName>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="parameters" position="1" type="map"/>
</operands>
<operands contentType="-20" returnType="list" type="-13">
<operand name="l1" position="0" type="list"/>
<operand name="l" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-20" returnType="list" type="-13">
<operand name="l1" position="0" type="list"/>
<operand name="l" position="1" type="list"/>
</operands>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="c" position="0" type="rgb"/>
<operand name="i" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="string" type="-13">
<operand name="a" position="0" type="string"/>
<operand name="b" position="1" type="string"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="string" type="-13">
<operand name="a" position="0" type="string"/>
<operand name="b" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="c1" position="0" type="rgb"/>
<operand name="c2" position="1" type="rgb"/>
</operands>
<operands contentType="-13" returnType="matrix" type="-13">
<operand name="msi.gama.util.matrix.imatrix&lt;t&gt;" position="0" type="matrix"/>
<operand name="other" position="1" type="matrix"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="size" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
</combinaisonIO>
<documentation>
<result>the sum, union or concatenation of the two operands.returns a new list containing all the elements of both operandsa new color resulting from the sum of each component of the color with the right operanda new color resulting from the sum of the two operands, component by component</result>
<comment>+ is only defined with a list as left operand</comment>
<specialCases>
<case item="if the left-hand operand is a geometry and the rigth-hand operand a map (with [distance::float, quadrantSegments:: int (the number of line segments used to represent a quadrant of a circle), endCapStyle::int (1: (default) a semi-circle, 2: a straight line perpendicular to the end segment, 3: a half-square)]), returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged considering the right-hand operand parameters"/>
<case item="if the right operand is an object of any type (except list), + returns a copie of the left operand with this object"/>
<case item="if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float."/>
<case item="if the right operand is nil, + returns the left operand"/>
<case item="if both operands are points, returns their sum."/>
<case item="if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number."/>
<case item="if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance"/>
<case item="if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries"/>
</specialCases>
<examples>
<example code="shape + [distance::5.0, quadrantSegments::4, endCapStyle:: 2] -&gt; returns a geometry corresponding to the geometry of the agent applying the operator enlarged by a distance of 5, with 4 segments to represent a quadrant of a circle and a straight line perpendicular to the end segment"/>
<example code="[1,2,3,4,5,6] + 2 &#9;&#9;--: &#9;[1,2,3,4,5,6,2]"/>
<example code="[1,2,3,4,5,6] + 0 &#9;&#9;--:&#9; &#9;[1,2,3,4,5,6,0]"/>
<example code="1 + 1 &#9;--:&#9; 2"/>
<example code="[1,2,3,4,5,6] + [2,4,9] &#9;--: &#9;[1,2,3,4,5,6,2,4,9]"/>
<example code="[1,2,3,4,5,6] + [0,8] &#9;&#9;--: &#9;[1,2,3,4,5,6,0,8]"/>
<example code="rgb([255, 128, 32]) + 3 &#9;:--  &#9;rgb([255,131,35])"/>
<example code="{1, 2} + {4, 5} &#9;--:&#9; {5.0;7.0}"/>
<example code="{1, 2} + 4.5 &#9;--:&#9; {5.5, 6.5}"/>
<example code="{1, 2} + 4 &#9;--:&#9; {5.0;6.0}"/>
<example code="rgb([255, 128, 32]) + rgb('red') &#9;:--  &#9;rgb([255,128,32])"/>
<example code="1.0 + 1 &#8594; 2.0"/>
<example code="shape + 5 -&gt; returns a geometry corresponding to the geometry of the agent applying the operator enlarged by a distance of 5"/>
<example code="geom1 + geom2 -&gt; a geometry corresponding to union between geom1 and geom2"/>
</examples>
<seeAlso>
<see id="-"/>
<see id="-"/>
</seeAlso>
</documentation>
</operator>
<operator category="IMatrix" id="-" name="-">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="matrix" type="-13">
<operand name="msi.gama.util.matrix.imatrix&lt;t&gt;" position="0" type="matrix"/>
<operand name="other" position="1" type="matrix"/>
</operands>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="c1" position="0" type="rgb"/>
<operand name="c" position="1" type="rgb"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="size" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="int"/>
</operands>
<operands contentType="-20" returnType="list" type="-13">
<operand name="l1" position="0" type="list"/>
<operand name="l" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="c" position="0" type="rgb"/>
<operand name="i" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="target" position="1" type="species"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-20" returnType="list" type="-13">
<operand name="l1" position="0" type="list"/>
<operand name="l" position="1" type="list"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="x" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="x" position="0" type="int"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="agents" position="1" type="msi.gama.util.IList&lt;msi.gama.metamodel.shape.IShape&gt;"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>a new color resulting from the substraction of the two operands, component by componenta new color resulting from the substraction of each component of the color with the right operandthe difference of the two operandsreturns a new list in which all the elements of the right operand have been removed from the left one</result>
<comment>- is only defined with a list as left operand</comment>
<specialCases>
<case item="if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance"/>
<case item="if the right operand is an object of any type (except list), - returns a copie of the left operand without this object"/>
<case item="if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number."/>
<case item="if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries"/>
<case item="if both operands are points, returns their difference."/>
<case item="if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float."/>
<case item="if the right-operand is a species, returns the geometry resulting from the difference between the left-geometry and all of geometries all agents of the right-species"/>
<case item="if the right operand is empty or nil, - returns the left operand"/>
<case item="when it is used as an unary operator, - returns the opposite or the operand."/>
<case item="if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries"/>
</specialCases>
<examples>
<example code="rgb([255, 128, 32]) - rgb('red')   &#9;:--  &#9;rgb([0,128,32])"/>
<example code="shape - 5 -&gt; returns a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5"/>
<example code="{1, 2} - 4 &#9;--:&#9; {-3.0;-2.0}"/>
<example code="[1,2,3,4,5,6] - 2 &#9;&#9;--: &#9;[1,3,4,5,6]"/>
<example code="[1,2,3,4,5,6] - 0 &#9;&#9;--:&#9; &#9;[1,2,3,4,5,6]"/>
<example code="{1, 2} - 4.5 &#9;--:&#9; {-3.5, -2.5}"/>
<example code="geom1 - geom2 -&gt; a geometry corresponding to difference between geom1 and geom2"/>
<example code="rgb([255, 128, 32]) - 3 &#9;:--  &#9;rgb([252,125,29])"/>
<example code="{1, 2} - {4, 5} &#9;--:&#9; {-3.0;-3.0}"/>
<example code="1 - 1 &#9;--:&#9; 0"/>
<example code="geom1 - speciesA -&gt; a geometry corresponding to geom1 - (the geometry of all agents of species speciesA)"/>
<example code="[1,2,3,4,5,6] - [2,4,9] &#9;--: &#9;[1,3,5,6]"/>
<example code="[1,2,3,4,5,6] - [0,8] &#9;&#9;--:&#9; &#9;[1,2,3,4,5,6]"/>
<example code="- (-56) &#9;--:&#9; 56"/>
<example code="geom1 - [geom2, geom3, geom4] -&gt; a geometry corresponding to geom1 - (geom2 + geom3 + geom4)"/>
<example code="1.0 - 1 &#8594; 0.0"/>
</examples>
<seeAlso>
<see id="+"/>
</seeAlso>
</documentation>
</operator>
<operator category="Containers" id="min_of" name="min_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="any" type="-17">
<operand name="original" position="0" type="container"/>
<operand name="filter" position="1" type="any expression"/>
</operands>
</combinaisonIO>
<documentation>
<result>the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand</result>
<comment>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </comment>
<specialCases>
<case item="if the left-hand operand is nil, first_with returns nil"/>
</specialCases>
<examples>
<example code="[1,2,4,3,5,7,6,8] min_of (each * 100 ) &#9;&#9;&#9;--: &#9;100"/>
<example code="g2 min_of (length(g2 out_edges_of each) ) &#9;&#9;&#9;--: &#9;0"/>
<example code="(list(node) min_of (round(node(each).location.x))  --: &#9;4"/>
<example code="[1::2, 3::4, 5::6] min_of (each.value + 3) &#9;&#9;&#9;&#9;--: &#9;5"/>
</examples>
<seeAlso>
<see id="max_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Maths" id="cos" name="cos">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="rv" position="0" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the cosinus of the operand (in decimal degrees).</result>
<comment/>
<specialCases>
<case item="the argument is casted to an int before being evaluated. Integers outside the range [0-359] are normalized."/>
</specialCases>
<examples>
<example code="cos (0) &#8594; 1"/>
</examples>
<seeAlso>
<see id="sin"/>
<see id="tan"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="as_matrix" name="as_matrix">
<alternativeName/>
<documentation>
<result>casts the left operand into a matrix with right operand as preferrenced size</result>
<comment>This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.</comment>
<specialCases>
<case item="if the right operand is nil, as_matrix is equivalent to the matrix operator"/>
</specialCases>
<examples/>
<seeAlso>
<see id="matrix"/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-20" returnType="matrix" type="-13">
<operand name="val" position="0" type="any"/>
<operand name="size" position="1" type="point"/>
</operands>
<operands contentType="-20" returnType="matrix" type="-13">
<operand name="msi.gama.util.icontainer&lt;keytype,valuetype&gt;" position="0" type="container"/>
<operand name="preferredSize" position="1" type="point"/>
</operands>
</combinaisonIO>
</operator>
<operator category="GamaFileType" id="is_properties" name="is_properties">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="f" position="0" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>the operator tests whether the operand represents the name of a supported properties file</result>
<comment>cf. file type definition for supported (espacially image) file extensions.</comment>
<specialCases/>
<examples>
<example code="is_properties(&quot;../includes/Stupid_Cell.Data&quot;)    --:  false;"/>
<example code="is_properties(&quot;../includes/test.png&quot;)            --:  false;"/>
<example code="is_properties(&quot;../includes/test.properties&quot;)     --:  true;"/>
<example code="is_properties(&quot;../includes/test.shp&quot;)            --:  false;"/>
</examples>
<seeAlso>
<see id="properties"/>
<see id="is_text"/>
<see id="is_shape"/>
<see id="is_image"/>
</seeAlso>
</documentation>
</operator>
<operator category="Comparison" id="!=" name="!=">
<alternativeName>
<altName name="&lt;&gt;"/>
</alternativeName>
<documentation>
<result>true if both operands are different, false otherwise</result>
<comment> this operator will return false if the two operands are identical (i.e., the same object) or equal. Comparisons between nil values are permitted.</comment>
<specialCases/>
<examples>
<example code="3 != 3    &#9;--: false"/>
<example code="4.5 = 4.7  &#9;--:  false"/>
<example code="[2,3] != [2,3] --: false"/>
<example code="[2,4] != [2,3] --: true"/>
</examples>
<seeAlso>
<see id="="/>
</seeAlso>
</documentation>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="any"/>
<operand name="b" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Comparison" id="&lt;" name="&lt;">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="string"/>
<operand name="b" position="1" type="string"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if the left-hand operand is less than the right-hand operand, false otherwise.</result>
<comment/>
<specialCases>
<case item="if one of the operands is nil, returns false"/>
<case item="if both operands are points, returns true if only if left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one."/>
<case item="if the operands are strings, a lexicographic comparison is performed"/>
</specialCases>
<examples>
<example code="3.5 &lt; 7.6  --: true"/>
<example code="3 &lt; 7  --:  true"/>
<example code="3 &lt; 2.5  --: false"/>
<example code="{5,7} &lt; {4,6}  --: false"/>
<example code="{5,7} &lt; {4,8}  --: false"/>
<example code="3.5 &lt; 7  --: true"/>
<example code="abc &lt; aeb  --: true"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Transformations" id="translated_by" name="translated_by">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)</result>
<comment/>
<specialCases/>
<examples>
<example code="self translated_by 45 -&gt; returns the geometry resulting from a 10m translation to the geometry of the agent applying the operator."/>
</examples>
<seeAlso>
<see id="rotated_by"/>
<see id="transformed_by"/>
</seeAlso>
</documentation>
</operator>
<operator category="Queries" id="inside" name="inside">
<alternativeName/>
<combinaisonIO>
<operands contentType="-20" returnType="list of points" type="-13">
<operand name="targets" position="0" type="species"/>
<operand name="toBeCastedIntoGeometry" position="1" type="any"/>
</operands>
<operands contentType="-20" returnType="list of points" type="-13">
<operand name="targets" position="0" type="msi.gama.util.IContainer&lt;?,msi.gama.metamodel.shape.IShape&gt;"/>
<operand name="toBeCastedIntoGeometry" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>A list of agents among the left-operand list, covered by the operand (casted as a geometry).</result>
<comment/>
<specialCases>
<case item="if the left-operand is a species, return agents of the specified species (slightly more efficient than using list(species1), for instance)."/>
</specialCases>
<examples>
<example code="species1 inside(self) -&gt; return the agents of species species1 that are covered by the shape of the agent applying the operator."/>
<example code="[ag1, ag2, ag3] inside(self) -&gt; return the agents among ag1, ag2 and ag3 that are covered by the shape of the agent applying the operator."/>
</examples>
<seeAlso>
<see id="neighbours_at"/>
<see id="neighbours_of"/>
<see id="closest_to"/>
<see id="overlapping"/>
<see id="agents_overlapping"/>
<see id="agents_inside"/>
<see id="agent_closest_to"/>
</seeAlso>
</documentation>
</operator>
<operator category="Graphs" id="remove_node_from" name="remove_node_from">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="node" position="0" type="shape"/>
<operand name="g" position="1" type="graph"/>
</operands>
</combinaisonIO>
</operator>
<operator category="Comparison" id="&lt;=" name="&lt;=">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="string"/>
<operand name="b" position="1" type="string"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="point"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if the left-hand operand is less or equal than the right-hand operand, false otherwise.</result>
<comment/>
<specialCases>
<case item="if one of the operands is nil, returns false"/>
<case item="if the operands are strings, a lexicographic comparison is performed"/>
<case item="if both operands are points, returns true if only if left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one."/>
</specialCases>
<examples>
<example code="3 &lt;= 7  --:  true"/>
<example code="7.0 &lt;= 7  --: true"/>
<example code="abc &lt;= aeb  --: true"/>
<example code="3 &lt;= 2.5  --: false"/>
<example code="3.5 &lt;= 3.5  --: true"/>
<example code="{5,7} &lt;= {4,6}  --: false"/>
<example code="{5,7} &lt;= {4,8}  --: false"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="Comparison" id="&gt;=" name="&gt;=">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="string"/>
<operand name="b" position="1" type="string"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
</combinaisonIO>
<documentation>
<result>true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.</result>
<comment/>
<specialCases>
<case item="if one of the operands is nil, returns false"/>
<case item="if the operands are strings, a lexicographic comparison is performed"/>
<case item="if both operands are points, returns true if only if left component (x) of the left operand if greater than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one."/>
</specialCases>
<examples>
<example code="3 &gt;= 2.5  --: true"/>
<example code="3.5 &gt;= 7  --: false"/>
<example code="3 &gt;= 7  --:  false"/>
<example code="abc &gt;= aeb  --: false"/>
<example code="abc &gt;= abc  --: true"/>
<example code="{5,7} &gt;= {4,6}  --: true"/>
<example code="{5,7} &gt;= {4,8}  --: false"/>
<example code="3.5 &gt;= 3.5  --: true"/>
</examples>
<seeAlso/>
</documentation>
</operator>
<operator category="GraphsGraphstream" id="load_graph_from_graphml" name="load_graph_from_graphml">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="graph" type="-13">
<operand name="parameters" position="0" type="map"/>
</operands>
</combinaisonIO>
<documentation>
<result>returns a graph loaded from a given file following GEXF file format.</result>
<comment>GraphML is a comprehensive and easy-to-use file format for graphs based on XML.  See: http://graphml.graphdrawing.org/ for more details.The map operand should includes following elements:</comment>
<specialCases>
<case item="&quot;filename&quot;: the filename of the file containing the network"/>
<case item="&quot;edges_specy&quot;: the species of edges"/>
<case item="&quot;vertices_specy&quot;: the species of vertices"/>
</specialCases>
<examples>
<example code="let my_graph type: graph &lt;- load_graph_from_graphml( ["/>
<example code="&#9;&#9;&#9;&quot;filename&quot;::&quot;example_of_Graphml_file&quot;,"/>
<example code="&#9;&#9;&#9;&quot;edges_specy&quot;::edgeSpecy,"/>
<example code="&#9;&#9;&#9;&quot;vertices_specy&quot;::nodeSpecy] );"/>
</examples>
<seeAlso>
<see id="load_graph_from_dgs_old"/>
</seeAlso>
</documentation>
</operator>
<operator category="Cast" id="to_java" name="to_java">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="string" type="-13">
<operand name="val" position="0" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>represents the java way to write an expression in java, depending on its type</result>
<comment>NOT YET IMPLEMENTED</comment>
<specialCases/>
<examples/>
<seeAlso>
<see id="to_gaml"/>
</seeAlso>
</documentation>
</operator>
<operator category="Strings" id="last_index_of" name="last_index_of">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="int" type="-13">
<operand name="target" position="0" type="string"/>
<operand name="pattern" position="1" type="string"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="m" position="0" type="matrix"/>
<operand name="o" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="any" type="-13">
<operand name="m" position="0" type="map"/>
<operand name="o" position="1" type="any"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="l1" position="0" type="java.util.List"/>
<operand name="o" position="1" type="any"/>
</operands>
</combinaisonIO>
<documentation>
<result>the index of the last occurence of the right operand in the left operand container</result>
<comment>last_index_of is only defined for list, map and matrix. The definition of last_index_of and the type of the index depend on the container</comment>
<specialCases>
<case item="if the left operand is a matrix, last_index_of returns the index as a point"/>
<case item="if the left operand is a map, last_index_of returns the index as a pair"/>
<case item="if the left operand is a list, last_index_of returns the index as an integer"/>
</specialCases>
<examples>
<example code="matrix([[1,2,3],[4,5,4]]) last_index_of 4  &#9;--: &#9;{1.0;2.0}"/>
<example code="[1::2, 3::4, 5::4] last_index_of 4  &#9;--:  &#9;5::4"/>
<example code="[1,2,3,4,5,6] last_index_of 4  &#9;--: &#9;3"/>
<example code="[4,2,3,4,5,4] last_index_of 4  &#9;--: &#9;5"/>
</examples>
<seeAlso>
<see id="at"/>
<see id="last_index_of"/>
</seeAlso>
</documentation>
</operator>
<operator category="Points" id="&lt;-&gt;" name="&lt;-&gt;">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="point" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="bool" type="-13">
<operand name="g1" position="0" type="shape"/>
<operand name="g2" position="1" type="shape"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).</result>
<comment/>
<specialCases>
<case item="if one of the operand is null, returns true."/>
<case item="if one operand is a point, returns false if the point is included in the geometry."/>
</specialCases>
<examples>
<example code="polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]) -&gt; false."/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]) -&gt; false."/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from geometry({15,15}) -&gt; false."/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from geometry({25,25}) -&gt; true."/>
<example code="polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]) -&gt; true"/>
</examples>
<seeAlso>
<see id="intersects"/>
<see id="crosses"/>
<see id="overlaps"/>
<see id="partially_overlaps"/>
<see id="touches"/>
</seeAlso>
</documentation>
</operator>
<operator category="Points" id="*" name="*">
<alternativeName/>
<combinaisonIO>
<operands contentType="-13" returnType="float" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="p" position="1" type="point"/>
</operands>
<operands contentType="-13" returnType="int" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="d" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="int"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="point" type="-13">
<operand name="p1" position="0" type="point"/>
<operand name="d" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="shape" type="-13">
<operand name="g" position="0" type="shape"/>
<operand name="coefficient" position="1" type="float"/>
</operands>
<operands contentType="-13" returnType="float" type="-13">
<operand name="a" position="0" type="float"/>
<operand name="b" position="1" type="int"/>
</operands>
<operands contentType="-13" returnType="rgb" type="-13">
<operand name="c" position="0" type="rgb"/>
<operand name="i" position="1" type="int"/>
</operands>
</combinaisonIO>
<documentation>
<result>the product of the two operandsa new color resulting from the product of each component of the color with the right operand</result>
<comment/>
<specialCases>
<case item="if both operands are points, returns their scalar product"/>
<case item="if both operands are int, returns the product as an int"/>
<case item="if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number"/>
<case item="if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient"/>
</specialCases>
<examples>
<example code="{2,5} * {4.5, 5} &#9;--:  34.0"/>
<example code=""/>
<example code="{2,5} * 4 &#9;--: {8.0; 20.0}"/>
<example code="shape * 2 -&gt; returns a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 2"/>
<example code=""/>
<example code="rgb([255, 128, 32]) * 2 &#9;:--  &#9;rgb([255,255,64])"/>
</examples>
<seeAlso>
<see id="/"/>
</seeAlso>
</documentation>
</operator>
<operator category="Random" id="shuffle" name="shuffle">
<alternativeName/>
<combinaisonIO>
<operands contentType="-16" returnType="list" type="-13">
<operand name="target" position="0" type="list"/>
</operands>
<operands contentType="4" returnType="string" type="-13">
<operand name="target" position="0" type="string"/>
</operands>
<operands contentType="-16" returnType="matrix" type="-13">
<operand name="target" position="0" type="matrix"/>
</operands>
<operands contentType="-16" returnType="list" type="-13">
<operand name="target" position="0" type="species"/>
</operands>
</combinaisonIO>
<documentation>
<result>The elements of the operand in random order.</result>
<comment/>
<specialCases>
<case item="if the operand is empty, returns an empty list (or string, matrix)"/>
</specialCases>
<examples>
<example code="shuffle ([12, 13, 14]) -&gt; [14,12,13];"/>
<example code="shuffle ('abc') -&gt; 'bac'"/>
<example code="shuffle ([[&quot;c11&quot;,&quot;c12&quot;,&quot;c13&quot;],[&quot;c21&quot;,&quot;c22&quot;,&quot;c23&quot;]]) -&gt; [[&quot;c12&quot;,&quot;c21&quot;,&quot;c11&quot;],[&quot;c13&quot;,&quot;c22&quot;,&quot;c23&quot;]]"/>
<example code="shuffle (bug) -&gt;  shuffle the list of all agents of the `bug` species"/>
</examples>
<seeAlso>
<see id="reverse"/>
</seeAlso>
</documentation>
</operator>
</operators>
<skills>
<skill class="msi.gaml.skills.GridSkill" extends="situated" id="grid" name="grid">
<vars>
<var constant="false" depends_on="" name="color" type="rgb"/>
<var constant="false" depends_on="" name="agents" type="list"/>
<var constant="true" depends_on="" name="grid_x" type="int"/>
<var constant="true" depends_on="" name="grid_y" type="int"/>
</vars>
<actions/>
</skill>
<skill class="msi.gaml.skills.GeometricSkill" extends="" id="situated" name="situated">
<actions>
<action name="neighbourhood_exclusive" returnType="msi.gama.metamodel.shape.IShape">
<args>
<arg name="distance"/>
<arg name="species"/>
<arg name="buffer_others"/>
<arg name="buffer_in"/>
</args>
</action>
<action name="percieved_area" returnType="msi.gama.metamodel.shape.GamaShape">
<args>
<arg name="agent"/>
<arg name="geometry"/>
<arg name="range"/>
<arg name="precision"/>
</args>
</action>
</actions>
</skill>
<skill class="msi.gaml.architecture.user.UserFirstControlArchitecture" extends="msi.gaml.architecture.user.UserControlArchitecture" id="user_first" name="user_first">
<actions/>
</skill>
<skill class="msi.gaml.architecture.user.UserLastControlArchitecture" extends="msi.gaml.architecture.user.UserControlArchitecture" id="user_last" name="user_last">
<actions/>
</skill>
<skill class="msi.gaml.architecture.user.UserOnlyControlArchitecture" extends="msi.gaml.architecture.user.UserControlArchitecture" id="user_only" name="user_only">
<actions/>
</skill>
<skill class="msi.gaml.skills.WorldSkill" extends="situated" id="global" name="global">
<vars>
<var constant="false" depends_on="" name="fatal" type="bool"/>
<var constant="false" depends_on="" name="warnings" type="bool"/>
<var constant="false" depends_on="" doc="Represents the total time passed, in model time, since the beginning of the simulation" name="time" type="float"/>
<var constant="false" depends_on="" doc="The seed of the random number generator" name="seed" type="float"/>
<var constant="false" depends_on="" doc="Returns the current cycle of the simulation" name="cycle" type="int"/>
<var constant="false" depends_on="" doc="The random number generator to use for this simulation. Four different ones are at the disposal of the modeler: mersenne represents the default generator, based on the Mersenne-Twister algorithm. Very reliable; cellular is a cellular automaton based generator that should be a bit faster, but less reliable; xor is another choice. Much faster than the previous ones, but with short sequences; and java invokes the standard Java generator" name="rng" type="string"/>
<var constant="false" depends_on="" doc="Represents the value of the interval, in model time, between two simulation cycles" name="step" type="float"/>
<var constant="false" depends_on="" doc="Returns the current system time in milliseconds" name="machine_time" type="float"/>
<var constant="false" depends_on="" doc="Returns a string containing the duration, in milliseconds, of the previous simulation cycle" name="duration" type="string"/>
<var constant="false" depends_on="" doc="Returns a string containing the total duration, in milliseconds, of the simulation since it has been launched " name="total_duration" type="string"/>
<var constant="false" depends_on="" doc="Returns a string containing the average duration, in milliseconds, of a simulation cycle." name="average_duration" type="string"/>
<var constant="true" depends_on="" doc="Contains the absolute path to the folder in which the current model is located" name="model_path" type="string"/>
<var constant="true" depends_on="" doc="Contains the absolute path to the workspace of GAMA" name="workspace_path" type="string"/>
<var constant="true" depends_on="" doc="Contains the absolute path to the project in which the current model is located" name="project_path" type="string"/>
</vars>
<actions>
<action name="halt" returnType="java.lang.Object">
<args/>
</action>
<action name="pause" returnType="java.lang.Object">
<args/>
</action>
</actions>
</skill>
<skill class="msi.gaml.architecture.finite_state_machine.FsmArchitecture" extends="reflex" id="fsm" name="fsm">
<vars>
<var constant="false" depends_on="" name="state" type="string"/>
<var constant="true" depends_on="" name="states" type="list"/>
</vars>
<actions/>
</skill>
<skill class="msi.gaml.architecture.weighted_tasks.ProbabilisticTasksArchitecture" extends="weighted_tasks" id="probabilistic_tasks" name="probabilistic_tasks">
<actions/>
</skill>
<skill class="msi.gaml.architecture.weighted_tasks.WeightedTasksArchitecture" extends="reflex" id="weighted_tasks" name="weighted_tasks">
<actions/>
</skill>
<skill class="msi.gaml.architecture.weighted_tasks.SortedTasksArchitecture" extends="weighted_tasks" id="sorted_tasks" name="sorted_tasks">
<actions/>
</skill>
<skill class="msi.gaml.skills.MovingSkill" extends="situated" id="moving" name="moving">
<description>The moving skill is intended to define the minimal set of behaviours required from an agent that is able to move</description>
<vars>
<var constant="false" depends_on="" doc="the speed of the agent (in meter/second)" name="speed" type="float"/>
<var constant="false" depends_on="" doc="the absolute heading of the agent in degrees (in the range 0-359)" name="heading" type="int"/>
<var constant="false" depends_on="speed,heading,location" doc="continuously updated destination of the agent with respect to its speed and heading (read-only)" name="destination" type="point"/>
</vars>
<actions>
<action name="follow" returnType="msi.gama.util.IPath">
<args>
<arg name="speed"/>
<arg name="path"/>
</args>
</action>
<action name="goto" returnType="msi.gama.util.IPath">
<args>
<arg name="target"/>
<arg name="speed"/>
<arg name="on"/>
<arg name="return_path"/>
</args>
</action>
<action name="move" returnType="msi.gama.util.IPath">
<args>
<arg name="speed"/>
<arg name="heading"/>
<arg name="bounds"/>
</args>
</action>
<action name="wander" returnType="msi.gama.util.IPath">
<args>
<arg name="speed"/>
<arg name="amplitude"/>
<arg name="bounds"/>
</args>
</action>
</actions>
</skill>
<skill class="msi.gaml.skills.GraphSkill" extends="" id="graph_user" name="graph_user">
<actions/>
</skill>
<skill class="msi.gaml.architecture.reflex.ReflexArchitecture" extends="msi.gaml.architecture.reflex.AbstractArchitecture" id="reflex" name="reflex">
<actions/>
</skill>
</skills>
<speciess>
<species id="agent" name="agent"/>
<species id="experimentator" name="experimentator"/>
<species id="cluster_builder" name="cluster_builder"/>
<species id="world_species" name="world_species"/>
<species id="multicriteria_analyzer" name="multicriteria_analyzer"/>
</speciess>
<symbol>
<command id="arg" kind="2" name="arg">
<facets>
<facet name="name" omissible="true" optionl="false" type="new_temp"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="value" omissible="false" optionl="true" type="unknown"/>
<facet name="default" omissible="false" optionl="true" type="unknown"/>
</facets>
</command>
<command id="ask" kind="11" name="ask">
<facets>
<facet name="target" omissible="true" optionl="false" type="container"/>
<facet name="as" omissible="false" optionl="true" type="species"/>
</facets>
</command>
<command id="enter" kind="11" name="enter"/>
<command id="signal" kind="103" name="signal">
<facets>
<facet name="name" omissible="true" optionl="false" type="new_var"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="value" omissible="false" optionl="false" type="float"/>
<facet name="update" omissible="false" optionl="true" type="unknown"/>
<facet name="function" omissible="false" optionl="true" type="unknown"/>
<facet name="environment" omissible="false" optionl="false" type="species"/>
<facet name="decay" omissible="false" optionl="false" type="float"/>
<facet name="propagation" omissible="false" optionl="true" type="label"/>
<facet name="proportion" omissible="false" optionl="true" type="float"/>
<facet name="variation" omissible="false" optionl="true" type="float"/>
<facet name="range" omissible="false" optionl="true" type="float"/>
<facet name="among" omissible="false" optionl="true" type="list"/>
</facets>
</command>
<command id="choose" kind="11" name="choose"/>
<command id="monitor" kind="5" name="monitor">
<facets>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="refresh_every" omissible="false" optionl="true" type="int"/>
<facet name="value" omissible="false" optionl="false" type="unknown"/>
</facets>
</command>
<command id="population" kind="6" name="population">
<facets>
<facet name="position" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="point"/>
<facet name="transparency" omissible="false" optionl="true" type="float"/>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="aspect" omissible="false" optionl="true" type="id"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="draw" kind="2" name="draw">
<facets>
<facet name="geometry" omissible="false" optionl="true" type="geometry"/>
<facet name="shape" omissible="true" optionl="true" type="id"/>
<facet name="text" omissible="false" optionl="true" type="string"/>
<facet name="image" omissible="false" optionl="true" type="string"/>
<facet name="empty" omissible="false" optionl="true" type="bool"/>
<facet name="at" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="float"/>
<facet name="to" omissible="false" optionl="true" type="point"/>
<facet name="color" omissible="false" optionl="true" type="rgb"/>
<facet name="scale" omissible="false" optionl="true" type="float"/>
<facet name="rotate" omissible="false" optionl="true" type="int"/>
<facet name="font" omissible="false" optionl="true" type="string"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
<facet name="style" omissible="false" optionl="true" type="id"/>
</facets>
</command>
<command id="user_init" kind="3" name="user_init"/>
<command id="do" kind="2" name="do">
<facets>
<facet name="action" omissible="true" optionl="false" type="id"/>
<facet name="with" omissible="false" optionl="true" type="map"/>
<facet name="returns" omissible="false" optionl="true" type="new_temp"/>
</facets>
</command>
<command id="user_panel" kind="3" name="user_panel">
<facets>
<facet name="initial" omissible="false" optionl="true" type="bool"/>
<facet name="name" omissible="true" optionl="false" type="id"/>
</facets>
</command>
<command id="release" kind="11" name="release">
<facets>
<facet name="target" omissible="true" optionl="false" type="agent"/>
<facet name="as" omissible="false" optionl="true" type="species"/>
<facet name="in" omissible="false" optionl="true" type="agent"/>
<facet name="returns" omissible="false" optionl="true" type="new_temp"/>
</facets>
</command>
<command id="graphdisplay" kind="5" name="graphdisplay">
<facets>
<facet name="name" omissible="true" optionl="true" type="string"/>
<facet name="graph" omissible="false" optionl="false" type="graph"/>
<facet name="lowquality" omissible="false" optionl="true" type="bool"/>
</facets>
</command>
<command id="match" kind="11" name="match">
<facets>
<facet name="value" omissible="true" optionl="true" type="unknown"/>
</facets>
</command>
<command id="batch" kind="13" name="batch">
<facets>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="keep_seed" omissible="false" optionl="true" type="bool"/>
<facet name="repeat" omissible="false" optionl="true" type="int"/>
<facet name="until" omissible="false" optionl="true" type="bool"/>
<facet name="type" omissible="false" optionl="false" type="label"/>
</facets>
</command>
<command kind="102">
<facets>
<facet name="name" omissible="true" optionl="false" type="new_var"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="init" omissible="false" optionl="true" type="unknown"/>
<facet name="value" omissible="false" optionl="true" type="unknown"/>
<facet name="update" omissible="false" optionl="true" type="unknown"/>
<facet name="function" omissible="false" optionl="true" type="unknown"/>
<facet name="const" omissible="false" optionl="true" type="bool"/>
<facet name="category" omissible="false" optionl="true" type="label"/>
<facet name="parameter" omissible="false" optionl="true" type="label"/>
<facet name="size" omissible="false" optionl="true" type="int"/>
<facet name="of" omissible="false" optionl="true" type="type"/>
<facet name="fill_with" omissible="false" optionl="true" type="unknown"/>
</facets>
</command>
<command id="create" kind="11" name="create">
<facets>
<facet name="species" omissible="true" optionl="true" type="species"/>
<facet name="returns" omissible="false" optionl="true" type="new_temp"/>
<facet name="from" omissible="false" optionl="true" type="unknown"/>
<facet name="number" omissible="false" optionl="true" type="int"/>
<facet name="as" omissible="false" optionl="true" type="species"/>
<facet name="with" omissible="false" optionl="true" type="map"/>
<facet name="size" omissible="false" optionl="true" type="float"/>
<facet name="type" omissible="false" optionl="true" type="string"/>
</facets>
</command>
<command id="action" kind="11" name="action">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="of" omissible="false" optionl="true" type="type"/>
<facet name="pertinence" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="state" kind="3" name="state">
<facets>
<facet name="initial" omissible="false" optionl="true" type="bool"/>
<facet name="final" omissible="false" optionl="true" type="bool"/>
<facet name="name" omissible="true" optionl="false" type="id"/>
</facets>
</command>
<command id="remove" kind="2" name="remove">
<facets>
<facet name="item" omissible="true" optionl="true" type="unknown"/>
<facet name="from" omissible="false" optionl="false" type="container"/>
<facet name="index" omissible="false" optionl="true" type="unknown"/>
<facet name="key" omissible="false" optionl="true" type="unknown"/>
<facet name="all" omissible="false" optionl="true" type="unknown"/>
</facets>
</command>
<command id="primitive" kind="3" name="primitive">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="java" omissible="false" optionl="false" type="id"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
</facets>
</command>
<command id="text" kind="6" name="text">
<facets>
<facet name="value" omissible="false" optionl="false" type="string"/>
<facet name="position" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="int"/>
<facet name="transparency" omissible="false" optionl="true" type="float"/>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="font" omissible="false" optionl="true" type="id"/>
<facet name="color" omissible="false" optionl="true" type="rgb"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="transition" kind="11" name="transition">
<facets>
<facet name="when" omissible="true" optionl="true" type="bool"/>
<facet name="to" omissible="false" optionl="false" type="id"/>
</facets>
</command>
<command id="exhaustive" kind="9" name="exhaustive">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="maximize" omissible="false" optionl="true" type="float"/>
<facet name="minimize" omissible="false" optionl="true" type="float"/>
<facet name="aggregation" omissible="false" optionl="true" type="label"/>
</facets>
</command>
<command id="chain" kind="11" name="chain"/>
<command id="image" kind="6" name="image">
<facets>
<facet name="file" omissible="false" optionl="true" type="string"/>
<facet name="position" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="point"/>
<facet name="transparency" omissible="false" optionl="true" type="float"/>
<facet name="name" omissible="true" optionl="true" type="label"/>
<facet name="gis" omissible="false" optionl="true" type="string"/>
<facet name="color" omissible="false" optionl="true" type="rgb"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="grid" kind="6" name="grid">
<facets>
<facet name="position" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="point"/>
<facet name="transparency" omissible="false" optionl="true" type="float"/>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="lines" omissible="false" optionl="true" type="rgb"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="hill_climbing" kind="9" name="hill_climbing">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="iter_max" omissible="false" optionl="true" type="int"/>
<facet name="maximize" omissible="false" optionl="true" type="float"/>
<facet name="minimize" omissible="false" optionl="true" type="float"/>
<facet name="aggregation" omissible="false" optionl="true" type="label"/>
</facets>
</command>
<command id="return" kind="2" name="return">
<facets>
<facet name="value" omissible="true" optionl="false" type="unknown"/>
</facets>
</command>
<command id="user_command" kind="11" name="user_command">
<facets>
<facet name="action" omissible="false" optionl="true" type="id"/>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="when" omissible="false" optionl="true" type="bool"/>
<facet name="with" omissible="false" optionl="true" type="map"/>
</facets>
</command>
<command id="migrate" kind="11" name="migrate">
<facets>
<facet name="source" omissible="true" optionl="false" type="id"/>
<facet name="target" omissible="false" optionl="false" type="id"/>
<facet name="returns" omissible="false" optionl="true" type="new_temp"/>
</facets>
</command>
<command id="graphdisplaygl" kind="5" name="graphdisplaygl">
<facets>
<facet name="name" omissible="true" optionl="true" type="string"/>
</facets>
</command>
<command id="aspect" kind="3" name="aspect">
<facets>
<facet name="name" omissible="true" optionl="true" type="id"/>
</facets>
</command>
<command id="else" kind="11" name="else"/>
<command id="annealing" kind="9" name="annealing">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="temp_end" omissible="false" optionl="true" type="float"/>
<facet name="temp_decrease" omissible="false" optionl="true" type="float"/>
<facet name="temp_init" omissible="false" optionl="true" type="float"/>
<facet name="nb_iter_cst_temp" omissible="false" optionl="true" type="int"/>
<facet name="maximize" omissible="false" optionl="true" type="float"/>
<facet name="minimize" omissible="false" optionl="true" type="float"/>
<facet name="aggregation" omissible="false" optionl="true" type="label"/>
</facets>
</command>
<command id="if" kind="11" name="if">
<facets>
<facet name="condition" omissible="true" optionl="false" type="bool"/>
</facets>
</command>
<command id="reactive_tabu" kind="9" name="reactive_tabu">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="iter_max" omissible="false" optionl="true" type="int"/>
<facet name="tabu_list_size_init" omissible="false" optionl="true" type="int"/>
<facet name="tabu_list_size_max" omissible="false" optionl="true" type="int"/>
<facet name="tabu_list_size_min" omissible="false" optionl="true" type="int"/>
<facet name="nb_tests_wthout_col_max" omissible="false" optionl="true" type="int"/>
<facet name="cycle_size_max" omissible="false" optionl="true" type="int"/>
<facet name="cycle_size_min" omissible="false" optionl="true" type="int"/>
<facet name="maximize" omissible="false" optionl="true" type="float"/>
<facet name="minimize" omissible="false" optionl="true" type="float"/>
<facet name="aggregation" omissible="false" optionl="true" type="label"/>
</facets>
</command>
<command id="save" kind="2" name="save">
<facets>
<facet name="species" omissible="false" optionl="true" type="species"/>
<facet name="type" omissible="false" optionl="true" type="string"/>
<facet name="item" omissible="false" optionl="true" type="unknown"/>
<facet name="data" omissible="true" optionl="true" type="unknown"/>
<facet name="rewrite" omissible="false" optionl="true" type="bool"/>
<facet name="to" omissible="false" optionl="false" type="string"/>
<facet name="with" omissible="false" optionl="true" type="map"/>
</facets>
</command>
<command id="file" kind="5" name="file">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="data" omissible="false" optionl="false" type="string"/>
<facet name="refresh_every" omissible="false" optionl="true" type="int"/>
<facet name="header" omissible="false" optionl="true" type="string"/>
<facet name="footer" omissible="false" optionl="true" type="string"/>
<facet name="rewrite" omissible="false" optionl="true" type="bool"/>
<facet name="type" omissible="false" optionl="true" type="id"/>
</facets>
</command>
<command id="gui" kind="13" name="gui">
<facets>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="type" omissible="false" optionl="false" type="label"/>
</facets>
</command>
<command id="write" kind="2" name="write">
<facets>
<facet name="message" omissible="true" optionl="false" type="string"/>
</facets>
</command>
<command id="tabu" kind="9" name="tabu">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="iter_max" omissible="false" optionl="true" type="int"/>
<facet name="tabu_list_size" omissible="false" optionl="true" type="int"/>
<facet name="maximize" omissible="false" optionl="true" type="float"/>
<facet name="minimize" omissible="false" optionl="true" type="float"/>
<facet name="aggregation" omissible="false" optionl="true" type="label"/>
</facets>
</command>
<command id="species" kind="0" name="species">
<facets>
<facet name="width" omissible="false" optionl="true" type="int"/>
<facet name="height" omissible="false" optionl="true" type="int"/>
<facet name="neighbours" omissible="false" optionl="true" type="int"/>
<facet name="torus" omissible="false" optionl="true" type="bool"/>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="parent" omissible="false" optionl="true" type="id"/>
<facet name="skills" omissible="false" optionl="true" type="label"/>
<facet name="control" omissible="false" optionl="true" type="id"/>
<facet name="compile" omissible="false" optionl="true" type="bool"/>
<facet name="frequency" omissible="false" optionl="true" type="int"/>
<facet name="schedules" omissible="false" optionl="true" type="container"/>
<facet name="topology" omissible="false" optionl="true" type="topology"/>
</facets>
</command>
<command id="switch" kind="11" name="switch">
<facets>
<facet name="value" omissible="true" optionl="false" type="unknown"/>
</facets>
</command>
<command id="chart" kind="6" name="chart">
<facets>
<facet name="position" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="point"/>
<facet name="background" omissible="false" optionl="true" type="rgb"/>
<facet name="axes" omissible="false" optionl="true" type="rgb"/>
<facet name="type" omissible="false" optionl="true" type="id"/>
<facet name="style" omissible="false" optionl="true" type="id"/>
<facet name="transparency" omissible="false" optionl="true" type="float"/>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="font" omissible="false" optionl="true" type="id"/>
<facet name="color" omissible="false" optionl="true" type="rgb"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="output" kind="5" name="output"/>
<command id="data" kind="2" name="data">
<facets>
<facet name="value" omissible="false" optionl="false" type="float"/>
<facet name="name" omissible="false" optionl="true" type="id"/>
<facet name="legend" omissible="true" optionl="true" type="string"/>
<facet name="color" omissible="false" optionl="true" type="rgb"/>
<facet name="style" omissible="false" optionl="true" type="id"/>
</facets>
</command>
<command id="quadtree" kind="6" name="quadtree">
<facets>
<facet name="position" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="point"/>
<facet name="transparency" omissible="false" optionl="true" type="float"/>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command kind="101">
<facets>
<facet name="name" omissible="true" optionl="false" type="new_var"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="init" omissible="false" optionl="true" type="int"/>
<facet name="value" omissible="false" optionl="true" type="int"/>
<facet name="update" omissible="false" optionl="true" type="unknown"/>
<facet name="function" omissible="false" optionl="true" type="unknown"/>
<facet name="const" omissible="false" optionl="true" type="bool"/>
<facet name="category" omissible="false" optionl="true" type="label"/>
<facet name="parameter" omissible="false" optionl="true" type="label"/>
<facet name="min" omissible="false" optionl="true" type="int"/>
<facet name="max" omissible="false" optionl="true" type="int"/>
<facet name="step" omissible="false" optionl="true" type="int"/>
<facet name="among" omissible="false" optionl="true" type="list"/>
</facets>
</command>
<command id="put" kind="2" name="put">
<facets>
<facet name="at" omissible="false" optionl="true" type="unknown"/>
<facet name="key" omissible="false" optionl="true" type="unknown"/>
<facet name="all" omissible="false" optionl="true" type="unknown"/>
<facet name="item" omissible="true" optionl="true" type="unknown"/>
<facet name="edge" omissible="false" optionl="true" type="unknown"/>
<facet name="vertex" omissible="false" optionl="true" type="unknown"/>
<facet name="weight" omissible="false" optionl="true" type="float"/>
<facet name="in" omissible="false" optionl="false" type="container"/>
</facets>
</command>
<command id="save_batch" kind="9" name="save_batch">
<facets>
<facet name="to" omissible="false" optionl="false" type="label"/>
<facet name="rewrite" omissible="false" optionl="true" type="bool"/>
<facet name="data" omissible="true" optionl="true" type="unknown"/>
</facets>
</command>
<command id="user_input" kind="2" name="user_input">
<facets>
<facet name="name" omissible="true" optionl="true" type="label"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="init" omissible="false" optionl="true" type="unknown"/>
<facet name="min" omissible="false" optionl="true" type="float"/>
<facet name="max" omissible="false" optionl="true" type="float"/>
<facet name="returns" omissible="false" optionl="false" type="new_temp"/>
<facet name="among" omissible="false" optionl="true" type="list"/>
</facets>
</command>
<command id="loop" kind="11" name="loop">
<facets>
<facet name="from" omissible="false" optionl="true" type="int"/>
<facet name="to" omissible="false" optionl="true" type="int"/>
<facet name="step" omissible="false" optionl="true" type="int"/>
<facet name="var" omissible="true" optionl="true" type="new_temp"/>
<facet name="over" omissible="false" optionl="true" type="container"/>
<facet name="while" omissible="false" optionl="true" type="bool"/>
<facet name="times" omissible="false" optionl="true" type="int"/>
</facets>
</command>
<command kind="104">
<facets>
<facet name="name" omissible="true" optionl="false" type="new_var"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="init" omissible="false" optionl="true" type="unknown"/>
<facet name="value" omissible="false" optionl="true" type="unknown"/>
<facet name="update" omissible="false" optionl="true" type="unknown"/>
<facet name="function" omissible="false" optionl="true" type="unknown"/>
<facet name="const" omissible="false" optionl="true" type="bool"/>
<facet name="category" omissible="false" optionl="true" type="label"/>
<facet name="parameter" omissible="false" optionl="true" type="label"/>
<facet name="among" omissible="false" optionl="true" type="list"/>
</facets>
</command>
<command id="exit" kind="11" name="exit"/>
<command id="capture" kind="11" name="capture">
<facets>
<facet doc="The agent or agents that are bound to be captured" name="target" omissible="true" optionl="false" type="agent"/>
<facet name="as" omissible="false" optionl="true" type="species"/>
<facet name="returns" omissible="false" optionl="true" type="new_temp"/>
</facets>
</command>
<command id="parameter" kind="4" name="parameter">
<facets>
<facet name="name" omissible="true" optionl="true" type="label"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
<facet name="init" omissible="false" optionl="true" type="unknown"/>
<facet name="min" omissible="false" optionl="true" type="unknown"/>
<facet name="max" omissible="false" optionl="true" type="unknown"/>
<facet name="category" omissible="false" optionl="true" type="label"/>
<facet name="var" omissible="false" optionl="false" type="id"/>
<facet name="unit" omissible="false" optionl="true" type="label"/>
<facet name="step" omissible="false" optionl="true" type="float"/>
<facet name="among" omissible="false" optionl="true" type="list"/>
</facets>
</command>
<command id="display" kind="5" name="display">
<facets>
<facet name="background" omissible="false" optionl="true" type="rgb"/>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="type" omissible="false" optionl="true" type="label"/>
<facet name="refresh_every" omissible="false" optionl="true" type="int"/>
<facet name="autosave" omissible="false" optionl="true" type="bool"/>
</facets>
</command>
<command id="agents" kind="6" name="agents">
<facets>
<facet name="value" omissible="false" optionl="false" type="container"/>
<facet name="position" omissible="false" optionl="true" type="point"/>
<facet name="size" omissible="false" optionl="true" type="point"/>
<facet name="transparency" omissible="false" optionl="true" type="float"/>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="focus" omissible="false" optionl="true" type="agent"/>
<facet name="aspect" omissible="false" optionl="true" type="id"/>
<facet name="z" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="break" kind="2" name="break"/>
<command id="inspect" kind="5" name="inspect">
<facets>
<facet name="name" omissible="true" optionl="false" type="label"/>
<facet name="refresh_every" omissible="false" optionl="true" type="int"/>
<facet name="value" omissible="false" optionl="true" type="unknown"/>
<facet name="type" omissible="false" optionl="false" type="id"/>
</facets>
</command>
<command id="environment" kind="10" name="environment">
<facets>
<facet name="width" omissible="false" optionl="true" type="int"/>
<facet name="height" omissible="false" optionl="true" type="int"/>
<facet name="torus" omissible="false" optionl="true" type="bool"/>
<facet name="bounds" omissible="true" optionl="true" type="unknown"/>
</facets>
</command>
<command id="reflex" kind="3" name="reflex">
<facets>
<facet name="when" omissible="false" optionl="true" type="bool"/>
<facet name="name" omissible="true" optionl="true" type="id"/>
</facets>
</command>
<command id="model" kind="1" name="model">
<facets>
<facet name="name" omissible="true" optionl="true" type="id"/>
<facet name="version" omissible="false" optionl="true" type="id"/>
<facet name="author" omissible="false" optionl="true" type="id"/>
</facets>
</command>
<command id="let" kind="2" name="let">
<facets>
<facet name="var" omissible="false" optionl="true" type="new_temp"/>
<facet name="name" omissible="true" optionl="true" type="new_temp"/>
<facet name="value" omissible="false" optionl="false" type="unknown"/>
<facet name="of" omissible="false" optionl="true" type="type"/>
<facet name="type" omissible="false" optionl="true" type="type"/>
</facets>
</command>
<command id="add" kind="2" name="add">
<facets>
<facet name="to" omissible="false" optionl="false" type="container"/>
<facet name="item" omissible="true" optionl="true" type="unknown"/>
<facet name="edge" omissible="false" optionl="true" type="unknown"/>
<facet name="vertex" omissible="false" optionl="true" type="unknown"/>
<facet name="at" omissible="false" optionl="true" type="unknown"/>
<facet name="all" omissible="false" optionl="true" type="unknown"/>
<facet name="weight" omissible="false" optionl="true" type="float"/>
</facets>
</command>
<command id="entities" kind="14" name="entities"/>
<command id="with" kind="2" name="with">
<facets>
<facet name="init" omissible="true" optionl="false" type="unknown"/>
</facets>
</command>
<command id="genetic" kind="9" name="genetic">
<facets>
<facet name="name" omissible="true" optionl="false" type="id"/>
<facet name="pop_dim" omissible="false" optionl="true" type="int"/>
<facet name="crossover_prob" omissible="false" optionl="true" type="float"/>
<facet name="mutation_prob" omissible="false" optionl="true" type="float"/>
<facet name="nb_prelim_gen" omissible="false" optionl="true" type="int"/>
<facet name="max_gen" omissible="false" optionl="true" type="int"/>
<facet name="maximize" omissible="false" optionl="true" type="float"/>
<facet name="minimize" omissible="false" optionl="true" type="float"/>
<facet name="aggregation" omissible="false" optionl="true" type="label"/>
</facets>
</command>
<command id="task" kind="3" name="task">
<facets>
<facet name="weight" omissible="false" optionl="false" type="float"/>
<facet name="name" omissible="true" optionl="false" type="id"/>
</facets>
</command>
<command id="warn" kind="2" name="warn">
<facets>
<facet name="message" omissible="true" optionl="false" type="string"/>
</facets>
</command>
<command id="set" kind="2" name="set">
<facets>
<facet name="var" omissible="true" optionl="true" type="unknown"/>
<facet name="name" omissible="false" optionl="true" type="unknown"/>
<facet name="value" omissible="false" optionl="false" type="unknown"/>
</facets>
</command>
<command id="error" kind="2" name="error">
<facets>
<facet name="message" omissible="true" optionl="false" type="string"/>
</facets>
</command>
</symbol>
</doc>

