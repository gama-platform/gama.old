#
#Thu May 31 11:40:25 CEST 2012
?^$Double$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?load_graph_from_pajek$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromPajek(scope,((GamaMap)target));}}
?sort_by$IContainer$IExpression$false$-13$-20$true$6$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.sort(scope,((IContainer)left),((IExpression)right));}}
(agent$11$104$IAgent=GamaGenericAgentType
?*$GamaPoint$Double$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.multiply(((GamaPoint)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?-$GamaPoint$Double$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.substract(((GamaPoint)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
)user_last=UserLastControlArchitecture
*getDarker$GamaColor=@Override public GamaColor value(final IValue v)  { if (v \=\= null) return  (GamaColor)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaColor.class), null) ; \nGamaColor result \= ((GamaColor) v).getDarker(); return result;}
)situated=GeometricSkill
?among$Integer$IContainer$false$-13$-19$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.opAmong(scope,(left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),((IContainer)right));}}
?around$Double$Object$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Creation.opFringe(scope,(left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),((Object)right));}}
?read$IGamaFile$$false$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.opRead(scope,((IGamaFile)target));}}
?shuffle$String$$false$-13$4$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opShuffle(scope,((String)target));}}
?load_graph_from_dgs$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromDGS(scope,((GamaMap)target));}}
?@$IContainer$Object$true$-20$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) left).get(((Object)right));}}
?of_species$IList$ISpecies$false$-13$-19$false$3$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opOfSpecies(((IList)left),((ISpecies)right));}}
?harmonic_mean$GamaList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Stats.opHarmonicMean(scope,((GamaList)target));}}
*getY$ILocation=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((ILocation) v).getY(); return result;}
*getContents$IGamaFile=@Override public IContainer value(final IValue v)  { if (v \=\= null) return  (IContainer)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IContainer.class), null) ; \nIContainer result \= ((IGamaFile) v).getContents(); return result;}
?-$Integer$Integer$true$-13$-13$false$5$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opMinus((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?**$Double$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
)fsm=FsmArchitecture
?neighbours_of$ITopology$IAgent$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opNeighboursOf(scope,((ITopology)left),((IAgent)right));}}
%"bool"$"initer","getWarningsAsErrors","const","false","getter","getWarningsAsErrors","name","warnings","setter","setWarningsAsErrors","init","false","type","bool"=WorldSkill
?enlarged_by$IShape$GamaMap$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opBuffer(((IShape)left),((GamaMap)right));}}
?>$Integer$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greater((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
-setHost$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setHost((IAgent)arg); }
?*$GamaPoint$GamaPoint$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.multiply(((GamaPoint)left),((GamaPoint)right));}}
(list$5$102$IList$List=GamaListType
/getPeers$IGamlAgent=@Override public IList execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \n  return (IList)((IGamlAgent) target).getPeers();}
?sin$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.sin((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?>$Double$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greater((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
)sorted_tasks=SortedTasksArchitecture
?map$IContainer$$true$-13$-13$false$98$Map=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Map execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (Map)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Map.class), null) ; \nreturn ((IContainer) target).mapValue(scope);}}
%"string"$"const","false","getter","getStateName","name","state","setter","setStateName","type","string"=FsmArchitecture
?collect$IContainer$IExpression$false$-13$-17$true$6$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.collect(scope,((IContainer)left),((IExpression)right));}}
?even$Integer$$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.even((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?triangulate$IShape$$false$-13$13$false$98$GamaList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Transformations.primTriangulate(((IShape)target));}}
%"point"$"const","false","getter","getDimensions","name","dimension","type","point"=IMatrix
[11$true$true$true$true$create=CreateStatement
\!primClusteringDBScan$msi.gaml.extensions.cluster_builder.ClusterBuilder$clustering_DBScan$"agents","attributes","distance_f","epsilon","min_points"=\n\t\t\t@Override\n\t\t\tpublic List execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.cluster_builder.ClusterBuilder) target).primClusteringDBScan(scope);  }\n@Override public IType getReturnType() { return Types.get(List.class);}
%"list"$"const","false","getter","getVertices","name","vertices","type","list"=IGraph
%"bool"$"initer","isReadable","const","false","getter","isReadable","name","readable","type","bool"=IGamaFile
(path$17$104$IPath$GamaPath=GamaPathType
%"string"$"initer","getPath","const","false","getter","getPath","name","path","type","string"=IGamaFile
?^$Double$Integer$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?<->$Double$Integer$true$-13$-13$false$0$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.toPoint((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
%"string"$"const","false","getter","getDuration","name","duration","type","string"=WorldSkill
%"list"$"of","geometry","const","false","getter","getEdgeList","name","segments","type","list"=IPath
(rgb$6$104$GamaColor$java.awt.Color=GamaColorType
?contains_edge$IGraph$GamaPair$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.containsEdge(((IGraph)left),((GamaPair)right));}}
[3$false$false$true$true$state=FsmStateStatement
?line$IList$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opPolyline(((IList)target));}}
*red$GamaColor=@Override public Integer value(final IValue v)  { if (v \=\= null) return  0 ; \nInteger result \= ((GamaColor) v).red(); return result;}
?union$ISpecies$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Operators.opUnion(scope,((ISpecies)target));}}
?rewire_p$IGraph$Double$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.rewireGraph(((IGraph)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
]1$13,0,10,5=ModelFactory
?acos$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.acos((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
*getName$IGamaFile=@Override public String value(final IValue v)  { if (v \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \nString result \= ((IGamaFile) v).getName(); return result;}
?max$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).max(scope);}}
?towards$IShape$IShape$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opTowards(scope,((IShape)left),((IShape)right));}}
?crosses$IShape$IShape$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Properties.opCrosses(((IShape)left),((IShape)right));}}
]9=BatchFactory
-setTime$WorldSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((WorldSkill) target).setTime(agent, (Double)arg); }
)user_first=UserFirstControlArchitecture
]6=msi.gama.outputs.layers.OutputLayerFactory
[11$false$true$true$true$user_command=UserCommandStatement
?copy_between$String$GamaPoint$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opCopy(((String)left),((GamaPoint)right));}}
?-$Integer$$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.negate((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?intersects$IShape$IShape$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Properties.opIntersects(((IShape)left),((IShape)right));}}
?+$Double$Double$true$-13$-13$false$5$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opPlus((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?last$ISpecies$$false$-16$-16$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Containers.getLast(scope,((ISpecies)target));}}
?square$Double$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opSquare(scope,(target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
%"container"$"const","false","getter","getContents","name","contents","type","container"=IGamaFile
?length$ISpecies$$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Containers.getLength(scope,((ISpecies)target));}}
?at_location$IShape$ILocation$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.primTranslationTo(((IShape)left),((ILocation)right));}}
)grid=GridSkill
%"list"$"of","agent","const","false","getter","getAgents","name","agents","setter","setAgents","type","list"=GridSkill¤IGamlAgent
[5$false$false$true$true$graphdisplaygl=msi.gama.opengl.GLOutput
?simple_clustering_by_envelope_distance$IList$Double$false$-13$5$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Statistics.simpleClusteringByEnvelopeDistance(scope,((IList)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
[11$true$false$true$true$ask=AskStatement
?inside$IContainer$Object$false$-13$-20$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opInside(scope,((IContainer)left),((Object)right));}}
%"unknown"$"const","false","getter","first","name","key","type","unknown"=GamaPair
?<\=$Double$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.lessOrEqual((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
[2$false$false$true$false$draw=DrawStatement
?/$Integer$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opDivide((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
%"string"$"initer","getName","const","false","getter","getName","name","name","type","string"=IGamaFile
?intersects$IShape$GamaPoint$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Properties.opIntersects(((IShape)left),((GamaPoint)right));}}
%"list"$"const","false","getter","getPeers","name","peers","setter","setPeers","type","list"=IGamlAgent
?agent_closest_to$Object$$false$0$-13$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Queries.opAgentsClosestTo(scope,((Object)target));}}
[11$false$false$true$true$match$match_between$match_one$default=MatchStatement
?simplification$IShape$Double$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opSimplication(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?-$Double$Double$true$-13$-13$false$5$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opMinus((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
[9$false$false$true$false$annealing=msi.gama.kernel.batch.SimulatedAnnealing
%"float"$"const","false","getter","getPerimeter","name","perimeter","type","float"=IShape
?count$IContainer$IExpression$false$-13$-13$true$6$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.count(scope,((IContainer)left),((IExpression)right));}}
%"float"$"const","false","getter","getTime","name","time","setter","setTime","type","float"=WorldSkill
[11$false$false$true$true$else=ElseStatement
[101$false$false$true$false=NumberVariable
]5$6=OutputFactory
%"list"$"of","geometry","const","false","getter","getHoles","name","holes","type","list"=GamaShape
?+$IShape$GamaMap$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opBuffer(((IShape)left),((GamaMap)right));}}
?+$GamaColor$Integer$true$-13$-13$false$5$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Colors.add(((GamaColor)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?target_of$IGraph$Object$false$-20$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.targetOf(((IGraph)left),((Object)right));}}
?rows_list$IMatrix$$true$-13$5$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nreturn ((IMatrix) target).getRowsList();}}
[0$false$false$true$true$species$global$grid=GamlSpecies
-setAgents$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setAgents((IList)arg); }
?of$IAgent$IExpression$false$-17$-19$false$99$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.System.opGetValue(scope,((IAgent)left),((IExpression)right));}}
[3$false$false$true$true$user_panel=UserPanelStatement
?contains_any$String$List$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opContainsAny(((String)left),((List)right));}}
[3$false$false$true$true$user_init=UserInitPanelStatement
?with_precision$Double$Integer$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opTruncate((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
-setColor$GridSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((GridSkill) target).setColor(agent, (GamaColor)arg); }
%"list"$"of","geometry","const","false","getter","getGeometries","name","geometries","type","list"=GamaShape
*getEdgeList$IPath=@Override public IList value(final IValue v)  { if (v \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nIList result \= ((IPath) v).getEdgeList(); return result;}
?load_graph_from_tlp$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromTLP(scope,((GamaMap)target));}}
?text$String$$false$-13$-13$false$98$IGamaFile=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGamaFile execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.textFile(scope,((String)target));}}
%"geometry"$"const","false","getter","getEnvironment","name","environment","type","geometry"=ITopology
?empty$IContainer$$true$-13$-13$false$98$boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  false ; \nreturn ((IContainer) target).isEmpty();}}
?every$Integer$$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.System.opEvery(scope,(target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
\!primWrite$GamlAgent$write$"message"=\n\t\t\t@Override\n\t\t\tpublic Object execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((GamlAgent) target).primWrite(scope);  }\n@Override public IType getReturnType() { return Types.get(Object.class);}
?<$GamaPoint$GamaPoint$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.less(((GamaPoint)left),((GamaPoint)right));}}
?rewire_n$IGraph$Integer$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.rewireGraph(((IGraph)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?closest_to$ISpecies$IShape$false$-20$-13$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opClosestTo(scope,((ISpecies)left),((IShape)right));}}
\!primPause$WorldSkill$pause=\n\t\t\t@Override\n\t\t\tpublic Object execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((WorldSkill) target).primPause(scope);  }\n@Override public IType getReturnType() { return Types.get(Object.class);}
?generate_watts_strogatz$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.generateGraphstreamWattsStrogatz(scope,((GamaMap)target));}}
?rnd$GamaPoint$$false$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opRnd(scope,((GamaPoint)target));}}
[9$false$false$true$false$tabu=msi.gama.kernel.batch.TabuSearch
%"geometry"$"const","false","getter","getExteriorRing","name","contour","type","geometry"=GamaShape
/getName$IGamlAgent=@Override public String execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \n  return (String)((IGamlAgent) target).getName();}
?enlarged_by$IShape$Double$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opBuffer(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?int$Object$$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asInt(scope,((Object)target));}}
?abs$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.abs((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?contains_edge$IGraph$Object$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.containsEdge(((IGraph)left),((Object)right));}}
?round$Double$$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.round((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?cos$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.cos((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
/getX$GridSkill=@Override public Integer execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  0 ; \n  return (Integer)((GridSkill) target).getX(agent);}
?/$Double$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opDivide((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?flip$Double$$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opFlip(scope,(target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
??$Boolean$IExpression$false$-17$-19$false$0$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Logic.iff(scope,(left \=\= null) ? false \: ((Boolean)left),((IExpression)right));}}
?write$IGamaFile$$false$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.opWrite(scope,((IGamaFile)target));}}
*isMultiple$GamaShape=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((GamaShape) v).isMultiple(); return result;}
\!WeightedMeansDecisionMaking$msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer$weighted_means_DM$"candidates","criteria"=\n\t\t\t@Override\n\t\t\tpublic Integer execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer) target).WeightedMeansDecisionMaking(scope);  }\n@Override public IType getReturnType() { return Types.get(Integer.class);}
?agent_from_geometry$IPath$IShape$false$-13$-13$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.getAgentFromGeom(((IPath)left),((IShape)right));}}
?-$Double$Integer$true$-13$-13$false$5$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opMinus((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?mean_deviation$GamaList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Stats.opMeanDeviation(scope,((GamaList)target));}}
?direction_between$ITopology$IContainer$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opDirectionBetween(scope,((ITopology)left),((IContainer)right));}}
%"container"$"of","geometry","const","false","getter","getPlaces","name","places","type","container"=ITopology
?truncated_gauss$IList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opTGauss(scope,((IList)target));}}
?>$Integer$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greater((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
*first$GamaPair=@Override public Object value(final IValue v)  { if (v \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nObject result \= ((GamaPair) v).first(); return result;}
?*$Integer$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opTimes((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
%"int"$"const","true","getter","getX","name","grid_x","setter","setX","type","int"=GridSkill
?gauss$GamaPoint$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opGauss(scope,((GamaPoint)target));}}
[2$false$false$true$false$add=AddStatement
?atan$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.atan((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
[9$false$false$true$false$save_batch=msi.gama.kernel.batch.BatchOutput
?graph$Object$$false$-13$-16$false$3$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asGraph(scope,((Object)target));}}
?evaluate_with$String$IExpression$false$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.System.opEvalJava(scope,((String)left),((IExpression)right));}}
?as_matrix$IContainer$ILocation$true$-13$-20$false$98$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\npublic IMatrix execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (IMatrix)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IMatrix.class), null) ; \nreturn ((IContainer) left).matrixValue(scope,((ILocation)right));}}
%"bool"$"initer","isFolder","const","false","getter","isFolder","name","is_folder","type","bool"=IGamaFile
?remove_node_from$IShape$IGraph$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.removeEdgeFrom(((IShape)left),((IGraph)right));}}
?polygon$IList$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opPolygon(((IList)target));}}
?weight_of$IGraph$Object$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.weightOf(((IGraph)left),((Object)right));}}
?simple_clustering_by_distance$IList$Double$false$-13$5$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Statistics.simpleClusteringByDistance(scope,((IList)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
[9$false$false$true$false$reactive_tabu=msi.gama.kernel.batch.TabuSearchReactive
[6$false$false$true$false$text=msi.gama.outputs.layers.TextLayerStatement
?@$String$int$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.get(((String)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
/getDestination$MovingSkill=@Override public ILocation execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (ILocation)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(ILocation.class), null) ; \n  return (ILocation)((MovingSkill) target).getDestination(agent);}
?index_of$IMatrix$Object$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opIndexOf(((IMatrix)left),((Object)right));}}
?-$IShape$IList$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.opDifferenceAgents(((IShape)left),((IList)right));}}
(float$2$101$Double$double=GamaFloatType
?-$GamaPoint$Integer$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.substract(((GamaPoint)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?<>$Double$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?where$IContainer$IExpression$false$-13$-20$true$6$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.where(scope,((IContainer)left),((IExpression)right));}}
?load_graph_from_ncol$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromNCol(scope,((GamaMap)target));}}
?-$GamaColor$GamaColor$true$-13$-13$false$5$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Colors.substract(((GamaColor)left),((GamaColor)right));}}
%"list"$"const","false","getter","getEdges","name","edges","type","list"=IGraph
?acos$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.acos((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
[11$false$false$true$true$transition=FsmTransitionStatement
[2$false$false$true$false$save=SaveStatement
(int$1$101$Integer$int$Long=GamaIntegerType
-setDestination$MovingSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((MovingSkill) target).setDestination(agent, (ILocation)arg); }
&multicriteria_analyzer=msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer
[9$false$false$true$false$exhaustive=msi.gama.kernel.batch.ExhaustiveSearch
/getSeed$WorldSkill=@Override public Double execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  0d ; \n  return (Double)((WorldSkill) target).getSeed(agent);}
?select$GamaMap$IExpression$false$-13$-13$true$6$GamaMap=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaMap execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.where(scope,((GamaMap)left),((IExpression)right));}}
?reverse$String$$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.reverse(((String)target));}}
]102,101,104,103,4=VariableFactory
?without_holes$IShape$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Transformations.opWithoutHoles(((IShape)target));}}
*getPairs$GamaMap=@Override public GamaList value(final IValue v)  { if (v \=\= null) return  (GamaList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaList.class), null) ; \nGamaList result \= ((GamaMap) v).getPairs(); return result;}
%"int"$"const","true","getter","getY","name","grid_y","setter","setY","type","int"=GridSkill
(graph$15$102$IGraph=GamaGraphType
-setStateName$FsmArchitecture=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((FsmArchitecture) target).setStateName(agent, (String)arg); }
?+$Double$Integer$true$-13$-13$false$5$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opPlus((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?closest_points_with$IShape$IShape$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Points.opClosestPointsBetween(((IShape)left),((IShape)right));}}
)weighted_tasks=WeightedTasksArchitecture
[11$false$false$true$true$choose=PertinenceChooseStatement
?*$GamaColor$Integer$true$-13$-13$false$4$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Colors.multiply(((GamaColor)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?contains$String$String$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opContains(((String)left),((String)right));}}
[6$false$false$true$true$chart=msi.gama.outputs.layers.ChartLayerStatement
?buffer$IShape$GamaMap$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opBuffer(((IShape)left),((GamaMap)right));}}
?neighbours_at$GamaPoint$Double$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opNeighboursAt(scope,((GamaPoint)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?load_graph_from_lgl$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromLGL(scope,((GamaMap)target));}}
%"bool"$"initer","exists","const","false","getter","exists","name","exists","type","bool"=IGamaFile
?as_map$IContainer$IExpression$false$-13$-13$true$6$GamaMap=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaMap execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.asMap(scope,((IContainer)left),((IExpression)right));}}
?columns_list$IMatrix$$true$-13$5$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nreturn ((IMatrix) target).getColumnsList();}}
?norm$GamaPoint$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Points.norm(((GamaPoint)target));}}
*last$GamaPoint=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((GamaPoint) v).last(); return result;}
?masked_by$IShape$ISpecies$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Operators.opMaskedBy(scope,((IShape)left),((ISpecies)right));}}
?group_by$IContainer$IExpression$false$-13$-13$false$6$GamaMap=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaMap execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.groupBy(scope,((IContainer)left),((IExpression)right));}}
[2$false$false$true$false$let=LetStatement
?reverse$IContainer$$true$-14$-16$false$98$IContainer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IContainer execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  (IContainer)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IContainer.class), null) ; \nreturn ((IContainer) target).reverse();}}
?copy_between$IList$GamaPoint$true$-13$-20$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opCopy(((IList)left),((GamaPoint)right));}}
?buffer$IShape$Double$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opBuffer(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
*getLocation$ILocated=@Override public ILocation value(final IValue v)  { if (v \=\= null) return  (ILocation)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(ILocation.class), null) ; \nILocation result \= ((ILocated) v).getLocation(); return result;}
?convex_hull$IShape$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Transformations.opConvexHull(((IShape)target));}}
?sqrt$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.sqrt((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?as_4_grid$IShape$GamaPoint$false$-13$13$false$98$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Transformations.opAs4Grid(scope,((IShape)left),((GamaPoint)right));}}
%"float"$"const","false","getter","getArea","name","area","type","float"=GamaShape
/getFatalErrors$WorldSkill=@Override public Boolean execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  false ; \n  return (Boolean)((WorldSkill) target).getFatalErrors(agent);}
%"bool"$"const","false","getter","isUserControlled","name","user_controlled","setter","setUserControlled","init","true","type","bool"=UserControlArchitecture
?at$ISpecies$GamaPoint$false$-13$-20$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.getAgent(scope,((ISpecies)left),((GamaPoint)right));}}
?last$String$$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.last(((String)target));}}
*getExtension$IGamaFile=@Override public String value(final IValue v)  { if (v \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \nString result \= ((IGamaFile) v).getExtension(); return result;}
*getPath$IGamaFile=@Override public String value(final IValue v)  { if (v \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \nString result \= ((IGamaFile) v).getPath(); return result;}
*getCircuit$IGraph=@Override public IValue value(final IValue v)  { if (v \=\= null) return  (IValue)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IValue.class), null) ; \nIValue result \= ((IGraph) v).getCircuit(); return result;}
?variance$GamaList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Stats.opVariance(scope,((GamaList)target));}}
-setX$GridSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((GridSkill) target).setX(agent, (Integer)arg); }
?neighbours_of$ITopology$GamaPair$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opNeighboursOf(scope,((ITopology)left),((GamaPair)right));}}
?\!\=$Integer$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
-setFatalErrors$WorldSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((WorldSkill) target).setFatalErrors(agent, (Boolean)arg); }
?/$Double$Integer$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opDivide((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
\!primTell$GamlAgent$tell$"message"=\n\t\t\t@Override\n\t\t\tpublic Object execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((GamlAgent) target).primTell(scope);  }\n@Override public IType getReturnType() { return Types.get(Object.class);}
?with_weights$IGraph$GamaMap$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Graphs.withWeights(scope,((IGraph)left),((GamaMap)right));}}
?pair$Object$$true$-13$-13$false$98$GamaPair=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaPair execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asPair(scope,((Object)target));}}
?-$IList$Object$true$-13$-20$false$5$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opMinus(((IList)left),((Object)right));}}
\!primError$GamlAgent$error$"message"=\n\t\t\t@Override\n\t\t\tpublic Object execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((GamlAgent) target).primError(scope);  }\n@Override public IType getReturnType() { return Types.get(Object.class);}
&default=GamlAgent
?among$Integer$GamaMap$false$-13$-19$false$98$GamaMap=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaMap execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.opAmong(scope,(left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),((GamaMap)right));}}
[9$false$false$true$false$genetic=msi.gama.kernel.batch.GeneticAlgorithm
?-$GamaColor$Integer$true$-13$-13$false$5$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Colors.substract(((GamaColor)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?max_of$IContainer$IExpression$false$-17$-13$true$6$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.maxOf(scope,((IContainer)left),((IExpression)right));}}
?as$Object$ISpecies$false$-19$-19$false$3$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Cast.asAgent(scope,((Object)left),((ISpecies)right));}}
*blue$GamaColor=@Override public Integer value(final IValue v)  { if (v \=\= null) return  0 ; \nInteger result \= ((GamaColor) v).blue(); return result;}
?+$IShape$IShape$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.opUnion(((IShape)left),((IShape)right));}}
?points_at$Integer$Double$false$-13$7$false$98$GamaList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Points.opPointsAt(scope,(left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
)probabilistic_tasks=ProbabilisticTasksArchitecture
?topology$Object$$false$-13$13$false$3$ITopology=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ITopology execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asTopology(scope,((Object)target));}}
[1$false$false$true$true$model=msi.gama.kernel.model.GamlModel
?shuffle$ISpecies$$false$-13$-16$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opShuffle(scope,((ISpecies)target));}}
?/$GamaPoint$Double$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.divide(((GamaPoint)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?mul$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).product(scope);}}
[6$false$false$true$false$data=msi.gama.outputs.layers.ChartDataStatement
%"bool"$"const","false","getter","isVerbose","name","verbose","type","bool"=IGraph
?farthest_point_to$IShape$GamaPoint$false$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Points.opFarthestPointTo(((IShape)left),((GamaPoint)right));}}
%"string"$"const","false","getter","getAverageDuration","name","average_duration","type","string"=WorldSkill
*getGraph$IPath=@Override public IGraph value(final IValue v)  { if (v \=\= null) return  (IGraph)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IGraph.class), null) ; \nIGraph result \= ((IPath) v).getGraph(); return result;}
(map$10$102$GamaMap$Map$HashMap=GamaMapType
%"list"$"initer","getStateNames","const","true","getter","getStateNames","name","states","setter","setStateNames","type","list"=FsmArchitecture
?load_graph_from_dgs_old$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromDGSOld(scope,((GamaMap)target));}}
?<\=$GamaPoint$GamaPoint$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.lessOrEqual(((GamaPoint)left),((GamaPoint)right));}}
[3$false$false$true$true$task=WeightedTaskStatement
-setHeading$MovingSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((MovingSkill) target).setHeading(agent, (Integer)arg); }
/getAverageDuration$WorldSkill=@Override public String execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \n  return (String)((WorldSkill) target).getAverageDuration(agent);}
-setMembers$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setMembers((IList)arg); }
*getPerimeter$IShape=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((IShape) v).getPerimeter(); return result;}
?overlapping$IContainer$Object$false$-13$-20$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opOverlapping(scope,((IContainer)left),((Object)right));}}
?min_of$IContainer$IExpression$false$-17$-13$true$6$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.minOf(scope,((IContainer)left),((IExpression)right));}}
*getAgentList$IPath=@Override public List value(final IValue v)  { if (v \=\= null) return  (List)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(List.class), null) ; \nList result \= ((IPath) v).getAgentList(); return result;}
?length$IContainer$$true$-13$-13$false$98$int=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  0 ; \nreturn ((IContainer) target).length();}}
\!primPercievedArea$GeometricSkill$percieved_area$"agent","geometry","range","precision"=\n\t\t\t@Override\n\t\t\tpublic GamaShape execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((GeometricSkill) target).primPercievedArea(scope);  }\n@Override public IType getReturnType() { return Types.get(GamaShape.class);}
?+$IMatrix$IMatrix$true$-13$-13$false$5$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (IMatrix)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IMatrix.class), null) ; \nreturn ((IMatrix) left).plus(((IMatrix)right));}}
*getCols$IMatrix=@Override public Integer value(final IValue v)  { if (v \=\= null) return  0 ; \nInteger result \= ((IMatrix) v).getCols(); return result;}
?last$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).last();}}
-setLocation$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setLocation((ILocation)arg); }
)reflex=ReflexArchitecture
*getVertices$IGraph=@Override public IList value(final IValue v)  { if (v \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nIList result \= ((IGraph) v).getVertices(); return result;}
*getStartVertex$IPath=@Override public ILocation value(final IValue v)  { if (v \=\= null) return  (ILocation)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(ILocation.class), null) ; \nILocation result \= ((IPath) v).getStartVertex(); return result;}
%"list"$"const","false","getter","getSpanningTree","name","spanning_tree","type","list"=IGraph
?last_index_of$IMatrix$Object$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opLastIndexOf(((IMatrix)left),((Object)right));}}
)graph_user=GraphSkill
[5$false$false$true$true$display=msi.gama.outputs.LayeredDisplayOutput
(bool$3$104$Boolean$boolean=GamaBoolType
?generate_barabasi_albert$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.generateGraphstreamBarabasiAlbert(scope,((GamaMap)target));}}
/getY$GridSkill=@Override public Integer execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  0 ; \n  return (Integer)((GridSkill) target).getY(agent);}
?point$Object$$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asPoint(scope,((Object)target));}}
?inter$IShape$IShape$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.opInter(((IShape)left),((IShape)right));}}
(unknown$0$104$Object=GamaNoType
?dead$IAgent$$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.System.opDead(scope,((IAgent)target));}}
?*$Double$Integer$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opTimes((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
%"point"$"const","false","getter","getLocation","name","location","type","point"=ILocated
-setAgents$GridSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((GridSkill) target).setAgents(agent, (GamaList)arg); }
%"string"$"const","false","getter","getName","name","name","setter","setName","type","string"=IGamlAgent
?file$String$$false$-13$-13$false$98$IGamaFile=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGamaFile execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.from(scope,((String)target));}}
?any$ISpecies$$false$-16$-13$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opAny(scope,((ISpecies)target));}}
?at$String$int$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.get(((String)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?/$Integer$Integer$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opDivide((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
-setSpeed$MovingSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((MovingSkill) target).setSpeed(agent, (Double)arg); }
?last_index_of$String$String$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opLastIndexOf(((String)left),((String)right));}}
?circle$Double$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opCircle(scope,(target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
\!primMoveRandomly$MovingSkill$wander$"speed","amplitude","bounds"=\n\t\t\t@Override\n\t\t\tpublic IPath execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((MovingSkill) target).primMoveRandomly(scope);  }\n@Override public IType getReturnType() { return Types.get(IPath.class);}
[11$false$true$true$true$action=ActionStatement
?translated_by$IShape$GamaPoint$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.primTranslationBy(((IShape)left),((GamaPoint)right));}}
?path_to$GamaPoint$GamaPoint$false$-13$-13$false$98$IPath=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IPath execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opPathTo(scope,((GamaPoint)left),((GamaPoint)right));}}
?mean$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Stats.getMean(scope,((IContainer)target));}}
[2$false$false$true$false$write=WriteStatement
*isWritable$GamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((GamaFile) v).isWritable(); return result;}
?closest_to$IContainer$IShape$false$-20$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opClosestTo(scope,((IContainer)left),((IShape)right));}}
&cluster_builder=msi.gaml.extensions.cluster_builder.ClusterBuilder
?bool$Object$$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asBool(scope,((Object)target));}}
?shapefile$String$$false$-13$-13$false$98$IGamaFile=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGamaFile execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.shapeFile(scope,((String)target));}}
?<\=$Integer$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.lessOrEqual((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
*getSpanningTree$IGraph=@Override public IList value(final IValue v)  { if (v \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nIList result \= ((IGraph) v).getSpanningTree(); return result;}
%"bool"$"initer","getFatalErrors","const","false","getter","getFatalErrors","name","fatal","setter","setFatalErrors","init","false","type","bool"=WorldSkill
?rnd$Integer$$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opRnd(scope,(target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
]11,2,3,11=StatementFactory
?<\=$Integer$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.opLessThanOrEqual((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?any_point_in$IShape$$false$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Points.opAnyLocationIn(scope,((IShape)target));}}
?union$IList$IList$true$-13$-20$false$5$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opUnion(((IList)left),((IList)right));}}
/getHost$IGamlAgent=@Override public IAgent execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (IAgent)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IAgent.class), null) ; \n  return (IAgent)((IGamlAgent) target).getHost();}
[2$false$false$true$false$error=ErrorStatement
?>\=$Integer$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greaterOrEqual((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?@$ISpecies$Integer$false$-13$-20$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.getAgent(scope,((ISpecies)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
[6$false$false$true$false$image=msi.gama.outputs.layers.ImageLayerStatement
?index_of$String$String$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opIndexOf(((String)left),((String)right));}}
%"path"$"const","false","getter","getCircuit","name","circuit","type","path"=IGraph
?as_edge_graph$IContainer$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Graphs.spatialFromEdges(scope,((IContainer)target));}}
?div$Double$Integer$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.div((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?source_of$IGraph$Object$false$-20$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.sourceOf(((IGraph)left),((Object)right));}}
?tan$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.tan((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
/getStateNames$FsmArchitecture=@Override public IList execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \n  return (IList)((FsmArchitecture) target).getStateNames(agent);}
?first$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).first();}}
-setTimeStep$WorldSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((WorldSkill) target).setTimeStep(agent, (Double)arg); }
[2$false$true$false$true$do$repeat=DoStatement
\!primGoto$MovingSkill$goto$"target","speed","on","return_path"=\n\t\t\t@Override\n\t\t\tpublic IPath execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((MovingSkill) target).primGoto(scope);  }\n@Override public IType getReturnType() { return Types.get(IPath.class);}
?binomial$GamaPoint$$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opBinomial(scope,((GamaPoint)target));}}
?/$GamaColor$Integer$true$-13$-13$false$4$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Colors.divide(((GamaColor)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
[5$false$false$true$false$inspect=msi.gama.outputs.InspectDisplayOutput
?distance_to$IShape$IShape$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opDistanceTo(scope,((IShape)left),((IShape)right));}}
?row_at$IMatrix$Integer$true$-13$-20$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nreturn ((IMatrix) left).getRow((right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
[2$false$false$true$false$put=PutStatement
\!primClusteringXMeans$msi.gaml.extensions.cluster_builder.ClusterBuilder$clustering_xmeans$"agents","attributes","bin_value","cut_off_factor","distance_f","max_iterations","max_kmeans","max_kmeans_for_children","max_kmeans_for_children","max_num_clusters","min_num_clusters","seed"=\n\t\t\t@Override\n\t\t\tpublic List execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.cluster_builder.ClusterBuilder) target).primClusteringXMeans(scope);  }\n@Override public IType getReturnType() { return Types.get(List.class);}
*getContents$GamaFile=@Override public IContainer value(final IValue v)  { if (v \=\= null) return  (IContainer)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IContainer.class), null) ; \nIContainer result \= ((GamaFile) v).getContents(); return result;}
?polyline$IList$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opPolyline(((IList)target));}}
%"int"$"const","false","getter","getCols","name","columns","type","int"=IMatrix
\!evidenceTheoryDecisionMaking$msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer$evidence_theory_DM$"candidates","criteria","simple"=\n\t\t\t@Override\n\t\t\tpublic Integer execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer) target).evidenceTheoryDecisionMaking(scope);  }\n@Override public IType getReturnType() { return Types.get(Integer.class);}
?at$IContainer$Object$true$-20$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) left).get(((Object)right));}}
/getTotalDuration$WorldSkill=@Override public String execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \n  return (String)((WorldSkill) target).getTotalDuration(agent);}
[2$false$false$true$false$remove=RemoveStatement
[11$false$false$true$true$loop=LoopStatement
?is_image$String$$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return GamaFileType.isImageFile(((String)target));}}
%"float"$"const","false","getter","getX","name","x","type","float"=ILocation
/getTime$WorldSkill=@Override public Double execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  0d ; \n  return (Double)((WorldSkill) target).getTime(agent);}
?get$IShape$String$false$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Files.opRead(scope,((IShape)left),((String)right));}}
\!primClusteringCobweb$msi.gaml.extensions.cluster_builder.ClusterBuilder$clustering_cobweb$"agents","attributes","acuity","cutoff","seed"=\n\t\t\t@Override\n\t\t\tpublic List execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.cluster_builder.ClusterBuilder) target).primClusteringCobweb(scope);  }\n@Override public IType getReturnType() { return Types.get(List.class);}
?tokenize$String$String$true$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opTokenize(((String)left),((String)right));}}
*isWritable$IGamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((IGamaFile) v).isWritable(); return result;}
?copy$Object$$false$-15$-16$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.System.opCopy(scope,((Object)target));}}
?\!\=$Double$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?<\=$Double$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.lessOrEqual((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
\!primDie$GamlAgent$die=\n\t\t\t@Override\n\t\t\tpublic Object execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((GamlAgent) target).primDie(scope);  }\n@Override public IType getReturnType() { return Types.get(Object.class);}
?last_with$IContainer$IExpression$false$-20$-13$true$6$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.last_with(scope,((IContainer)left),((IExpression)right));}}
/getWarningsAsErrors$WorldSkill=@Override public Boolean execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  false ; \n  return (Boolean)((WorldSkill) target).getWarningsAsErrors(agent);}
?atan$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.atan((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?-$IShape$Double$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opNegativeBuffer(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
/getAgents$GridSkill=@Override public List execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (List)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(List.class), null) ; \n  return (List)((GridSkill) target).getAgents(agent);}
?>$GamaPoint$GamaPoint$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greater(((GamaPoint)left),((GamaPoint)right));}}
[13$false$false$true$true$gui=msi.gama.kernel.experiment.GuiExperiment
[11$true$false$true$true$release=ReleaseStatement
?direction_to$IShape$IShape$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opTowards(scope,((IShape)left),((IShape)right));}}
?matrix$IContainer$$true$-13$-16$false$98$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (IMatrix)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IMatrix.class), null) ; \nreturn ((IContainer) target).matrixValue(scope);}}
?one_of$ISpecies$$false$-16$-13$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opAny(scope,((ISpecies)target));}}
]13$5,4,9,11,3=ExperimentFactory
?abs$Integer$$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.abs((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?geometry$Object$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asGeometry(scope,((Object)target));}}
?in$Object$IContainer$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opIn(((Object)left),((IContainer)right));}}
(pair$9$104$GamaPair=GamaPairType
[11$false$false$true$true$if=IfStatement
*getEnvironment$ITopology=@Override public IShape value(final IValue v)  { if (v \=\= null) return  (IShape)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IShape.class), null) ; \nIShape result \= ((ITopology) v).getEnvironment(); return result;}
-setY$GridSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((GridSkill) target).setY(agent, (Integer)arg); }
*getGeometries$GamaShape=@Override public GamaList value(final IValue v)  { if (v \=\= null) return  (GamaList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaList.class), null) ; \nGamaList result \= ((GamaShape) v).getGeometries(); return result;}
?transformed_by$IShape$GamaPoint$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.primAffinite(((IShape)left),((GamaPoint)right));}}
?>\=$Integer$Double$false$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greaterOrEqual((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
%"unknown"$"const","false","getter","getHost","name","host","setter","setHost","type","unknown"=IGamlAgent
?<>$Integer$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?unknown$Object$$true$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asObject(((Object)target));}}
*getConnected$IGraph=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((IGraph) v).getConnected(); return result;}
?div$Double$Double$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.div((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?<>$Double$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
]0$3,11,101,102,104,103=SpeciesFactory
*getValues$GamaMap=@Override public GamaList value(final IValue v)  { if (v \=\= null) return  (GamaList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaList.class), null) ; \nGamaList result \= ((GamaMap) v).getValues(); return result;}
?undirected$IGraph$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Graphs.asUndirectedGraph(((IGraph)target));}}
%"bool"$"const","false","getter","getConnected","name","connected","type","bool"=IGraph
?length$String$$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.length(((String)target));}}
?add_point$IShape$ILocation$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.opAddPoint(((IShape)left),((ILocation)right));}}
?load_graph_from_dot$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromDot(scope,((GamaMap)target));}}
[5$false$false$true$true$graphdisplay=msi.gama.networks.ui.GraphstreamOutput
-setGeometry$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setGeometry((IShape)arg); }
\!primClusteringFarthestFirst$msi.gaml.extensions.cluster_builder.ClusterBuilder$clustering_farthestFirst$"agents","attributes","num_clusters","seed"=\n\t\t\t@Override\n\t\t\tpublic List execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.cluster_builder.ClusterBuilder) target).primClusteringFarthestFirst(scope);  }\n@Override public IType getReturnType() { return Types.get(List.class);}
%"list"$"of","pair","const","false","getter","getPairs","name","pairs","type","list"=GamaMap
?mod$Integer$Integer$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Maths.opMod(scope,(left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
/getMembers$IGamlAgent=@Override public IList execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \n  return (IList)((IGamlAgent) target).getMembers();}
?+$IList$IList$true$-13$-20$false$5$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opPlus(((IList)left),((IList)right));}}
?/$GamaPoint$Integer$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.divide(((GamaPoint)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
/getColor$GridSkill=@Override public GamaColor execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (GamaColor)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaColor.class), null) ; \n  return (GamaColor)((GridSkill) target).getColor(agent);}
(geometry$13$104$GamaShape$IShape=GamaGeometryType
*getKeys$GamaMap=@Override public GamaList value(final IValue v)  { if (v \=\= null) return  (GamaList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaList.class), null) ; \nGamaList result \= ((GamaMap) v).getKeys(); return result;}
[13$false$false$true$true$batch=msi.gama.kernel.experiment.BatchExperiment
?skeletonize$IShape$$false$-13$13$false$98$GamaList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Transformations.primSkeletonization(scope,((IShape)target));}}
?partially_overlaps$IShape$IShape$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Properties.opPartiallyOverlaps(((IShape)left),((IShape)right));}}
?**$Integer$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?>\=$Double$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greaterOrEqual((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
/getRng$WorldSkill=@Override public String execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \n  return (String)((WorldSkill) target).getRng(agent);}
?+$IShape$Double$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opBuffer(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?+$String$String$true$-13$-13$false$5$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opPlus(((String)left),((String)right));}}
?fact$Integer$$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.fact((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
*getEndVertex$IPath=@Override public ILocation value(final IValue v)  { if (v \=\= null) return  (ILocation)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(ILocation.class), null) ; \nILocation result \= ((IPath) v).getEndVertex(); return result;}
%"float"$"const","false","getter","getSpeed","name","speed","setter","setSpeed","init","1.0","type","float"=MovingSkill
%"string"$"const","false","getter","getName","name","name","type","string"=GamlSpecies
?read$String$$false$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.opRead(scope,((String)target));}}
/getHeading$MovingSkill=@Override public Integer execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  0 ; \n  return (Integer)((MovingSkill) target).getHeading(agent);}
?-$IShape$ISpecies$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Operators.opDifferenceSpecies(scope,((IShape)left),((ISpecies)right));}}
?last_index_of$List$Object$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opLastIndexOf(((List)left),((Object)right));}}
?exp$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.exp((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?agents_inside$Object$$false$-13$0$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Queries.opAgentsIn(scope,((Object)target));}}
(file$12$102$IGamaFile$java.io.File=GamaFileType
*getBrighter$GamaColor=@Override public GamaColor value(final IValue v)  { if (v \=\= null) return  (GamaColor)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaColor.class), null) ; \nGamaColor result \= ((GamaColor) v).getBrighter(); return result;}
?split_with$String$String$true$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opTokenize(((String)left),((String)right));}}
-setStateNames$FsmArchitecture=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((FsmArchitecture) target).setStateNames(agent, (IList)arg); }
?one_of$IContainer$$false$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).any();}}
?in$String$String$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opIn(((String)left),((String)right));}}
?asin$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.asin((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
%"point"$"initer","getLocation","const","false","getter","getLocation","name","location","setter","setLocation","type","point","depends_on","shape"=IGamlAgent
?sort$IContainer$IExpression$false$-13$-20$true$6$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.sort(scope,((IContainer)left),((IExpression)right));}}
?frequency_of$IContainer$IExpression$false$-13$-13$true$6$GamaMap=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaMap execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Stats.frequencyOf(scope,((IContainer)left),((IExpression)right));}}
%"string"$"initer","getRng","const","false","getter","getRng","name","rng","setter","setRng","init","'mersenne'","type","string"=WorldSkill
?as_date$double$String$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.asDate((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),((String)right));}}
)global$world_species=WorldSkill
?times$IMatrix$IMatrix$true$-13$-13$false$4$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (IMatrix)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IMatrix.class), null) ; \nreturn ((IMatrix) left).times(((IMatrix)right));}}
?div$Integer$Double$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.div((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?+$Integer$Integer$true$-13$-13$false$5$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opPlus((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?neighbours_at$IShape$Double$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opNeighboursAt(scope,((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?-$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.negate((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?split_lines$IList$$false$-13$13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Transformations.splitLines(scope,((IList)target));}}
?remove_duplicates$IContainer$$true$-13$-16$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Containers.asSet(((IContainer)target));}}
?container$Object$$false$-13$-16$false$3$IContainer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IContainer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asContainer(scope,((Object)target));}}
*exists$GamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((GamaFile) v).exists(); return result;}
?reduced_by$IShape$Double$false$-13$-13$false$5$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opNegativeBuffer(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?sin$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.sin((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?load_graph_from_graphml$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromGraphML(scope,((GamaMap)target));}}
?product$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).product(scope);}}
?<$Integer$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.less((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?any$IContainer$$false$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).any();}}
?floor$double$$true$-13$-13$false$98$double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.floor((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
*first$GamaPoint=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((GamaPoint) v).first(); return result;}
?poisson$Double$$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opPoisson(scope,(target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?<>$Object$Object$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different(((Object)left),((Object)right));}}
?contains_all$IContainer$IContainer$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opContainsAll(((IContainer)left),((IContainer)right));}}
?median$GamaList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Stats.opMedian(scope,((GamaList)target));}}
(matrix$8$102$IMatrix$GamaIntMatrix$GamaFloatMatrix$GamaObjectMatrix=GamaMatrixType
?as_distance_graph$IContainer$Double$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Graphs.spatialDistanceGraph(scope,((IContainer)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
[10$false$false$true$false$environment=ModelEnvironment
?triangle$Double$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opTriangle(scope,(target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?in_edges_of$IGraph$Object$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.inEdgesOf(((IGraph)left),((Object)right));}}
?**$Integer$Integer$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?list$IContainer$$true$-13$-16$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nreturn ((IContainer) target).listValue(scope);}}
[103$false$false$true$false$signal=SignalVariable
?empty$String$$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.isEmpty(((String)target));}}
?path$Object$$false$-13$-13$false$98$IPath=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IPath execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Graphs.toPath(scope,((Object)target));}}
*isFolder$GamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((GamaFile) v).isFolder(); return result;}
[2$false$false$true$false$with=WithStatement
%"graph"$"const","false","getter","getGraph","name","graph","type","graph"=IPath
\!electreDecisionMaking$msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer$electre_DM$"candidates","criteria","fuzzy_cut"=\n\t\t\t@Override\n\t\t\tpublic Integer execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer) target).electreDecisionMaking(scope);  }\n@Override public IType getReturnType() { return Types.get(Integer.class);}
?first$String$$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.first(((String)target));}}
-setTopology$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setTopology((ITopology)arg); }
\!primClusteringEM$msi.gaml.extensions.cluster_builder.ClusterBuilder$clustering_em$"agents","attributes","max_iterations","num_clusters","min_std_dev","seed"=\n\t\t\t@Override\n\t\t\tpublic List execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.cluster_builder.ClusterBuilder) target).primClusteringEM(scope);  }\n@Override public IType getReturnType() { return Types.get(List.class);}
[6$false$false$true$false$quadtree=msi.gama.outputs.layers.QuadTreeLayerStatement
?asin$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.asin((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
]10,14=SymbolFactory
*getHeight$GamaShape=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((GamaShape) v).getHeight(); return result;}
/getAgents$IGamlAgent=@Override public IList execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \n  return (IList)((IGamlAgent) target).getAgents();}
?shuffle$IMatrix$$false$-13$-16$false$98$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opShuffle(scope,((IMatrix)target));}}
?-$GamaPoint$GamaPoint$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.substract(((GamaPoint)left),((GamaPoint)right));}}
*getPoints$GamaShape=@Override public IList value(final IValue v)  { if (v \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nIList result \= ((GamaShape) v).getPoints(); return result;}
[11$false$false$true$true$switch=SwitchStatement
?distance_to$GamaPoint$GamaPoint$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opDistanceTo(scope,((GamaPoint)left),((GamaPoint)right));}}
?min$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).min(scope);}}
?successors_of$IGraph$Object$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.successorsOf(((IGraph)left),((Object)right));}}
?+$IList$Object$true$-13$-20$false$5$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opPlus(((IList)left),((Object)right));}}
/getDuration$WorldSkill=@Override public String execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \n  return (String)((WorldSkill) target).getDuration(agent);}
%"rgb"$"const","false","getter","getDarker","name","darker","type","rgb"=GamaColor
?as_intersection_graph$IContainer$Double$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Graphs.spatialFromVertices(scope,((IContainer)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?TGauss$IList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opTGauss(scope,((IList)target));}}
?^$Integer$Integer$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?tan$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.tan((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?+$GamaPoint$Double$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.add(((GamaPoint)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
*getX$ILocation=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((ILocation) v).getX(); return result;}
%"rgb"$"const","false","getter","getBrighter","name","brighter","type","rgb"=GamaColor
[2$false$false$true$false$warn=WarnStatement
?new_folder$String$$false$-13$-13$false$98$IGamaFile=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGamaFile execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.newFolder(scope,((String)target));}}
?>\=$GamaPoint$GamaPoint$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greaterOrEqual(((GamaPoint)left),((GamaPoint)right));}}
?to_gaml$Object$$false$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.toGaml(((Object)target));}}
[3$false$false$true$true$reflex$init=ReflexStatement
?properties$String$$false$-13$-13$false$98$IGamaFile=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGamaFile execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.propertyFile(scope,((String)target));}}
(container$16$102$IContainer=GamaContainerType
?-$IShape$IShape$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.opDifference(((IShape)left),((IShape)right));}}
?rectangle$GamaPoint$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opRect(scope,((GamaPoint)target));}}
?*$Integer$Integer$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opTimes((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?list$Object$$true$-13$-16$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asList(scope,((Object)target));}}
*getExtension$GamaFile=@Override public String value(final IValue v)  { if (v \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \nString result \= ((GamaFile) v).getExtension(); return result;}
?<$Double$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.less((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
/getStateName$FsmArchitecture=@Override public String execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \n  return (String)((FsmArchitecture) target).getStateName(agent);}
?cos$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.cos((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?to_java$Object$$false$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.toJava(((Object)target));}}
[6$false$false$true$false$grid=msi.gama.outputs.layers.GridLayerStatement
?>$Double$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greater((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
%"list"$"const","false","getter","getKeys","name","keys","type","list"=GamaMap
?out_edges_of$IGraph$Object$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.outEdgesOf(((IGraph)left),((Object)right));}}
)moving=MovingSkill
%"string"$"initer","getExtension","const","false","getter","getExtension","name","extension","type","string"=IGamaFile
?split_at$IShape$ILocation$false$-13$-13$false$98$GamaList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.splitLineAt(((IShape)left),((ILocation)right));}}
?any_location_in$IShape$$false$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Points.opAnyLocationIn(scope,((IShape)target));}}
?matrix$Object$$true$-13$-16$false$98$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asMatrix(scope,((Object)target));}}
[5$false$false$true$true$output=msi.gama.outputs.OutputManager
?is$IExpression$IExpression$false$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Cast.isA(scope,((IExpression)left),((IExpression)right));}}
?touches$IShape$IShape$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Properties.opTouches(((IShape)left),((IShape)right));}}
?div$Integer$Integer$true$-13$-13$false$4$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.div((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?<\=$String$String$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.lessOrEqual(((String)left),((String)right));}}
?overlaps$IShape$IShape$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Properties.opOverlaps(scope,((IShape)left),((IShape)right));}}
(string$4$104$String=GamaStringType
?as_edge_graph$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Graphs.spatialFromEdges(scope,((GamaMap)target));}}
?<>$Integer$Integer$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?as_matrix$Object$ILocation$true$-13$-20$false$98$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Cast.asMatrix(scope,((Object)left),((ILocation)right));}}
?with_weights$IGraph$IList$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Graphs.withWeights(scope,((IGraph)left),((IList)right));}}
?clean$IShape$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Transformations.opClean(((IShape)target));}}
?directed$IGraph$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Graphs.asDirectedGraph(((IGraph)target));}}
?^$Integer$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?grid_at$ISpecies$GamaPoint$false$-13$-20$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.getGridAgent(scope,((ISpecies)left),((GamaPoint)right));}}
[5$false$false$true$false$file=msi.gama.outputs.FileOutput
?tanh$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.tanh((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?exp$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.exp((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?union$GamaList$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Operators.opUnion(scope,((GamaList)target));}}
/getLocation$IGamlAgent=@Override public ILocation execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (ILocation)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(ILocation.class), null) ; \n  return (ILocation)((IGamlAgent) target).getLocation();}
?load_graph_from_gexf$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromGEFX(scope,((GamaMap)target));}}
?float$Object$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asFloat(scope,((Object)target));}}
?user_input$Map$$false$-13$-13$false$98$Map=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Map execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.System.userInput(scope,((Map)target));}}
[102$false$false$true$false=ContainerVariable
?load_graph_from_edge$GamaMap$$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.GraphsGraphstream.primLoadGraphFromFileFromEdge(scope,((GamaMap)target));}}
?or$Boolean$IExpression$false$-13$-13$false$1$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Logic.or(scope,(left \=\= null) ? false \: ((Boolean)left),((IExpression)right));}}
*last$GamaPair=@Override public Object value(final IValue v)  { if (v \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nObject result \= ((GamaPair) v).last(); return result;}
\!primNeighbourhoodExclu$GeometricSkill$neighbourhood_exclusive$"distance","species","buffer_others","buffer_in"=\n\t\t\t@Override\n\t\t\tpublic IShape execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((GeometricSkill) target).primNeighbourhoodExclu(scope);  }\n@Override public IType getReturnType() { return Types.get(IShape.class);}
?**$Double$Integer$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.pow((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?as_grid$IShape$GamaPoint$false$-13$13$false$98$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Transformations.opAsGrid(scope,((IShape)left),((GamaPoint)right));}}
?index_of$IList$Object$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opIndexOf(((IList)left),((Object)right));}}
?rotated_by$IShape$Double$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.primRotation(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
%"point"$"const","false","getter","getDestination","name","destination","setter","setDestination","type","point","depends_on","speed\ heading\ location"=MovingSkill
?with_optimizer_type$IGraph$String$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Graphs.setOptimizeType(scope,((IGraph)left),((String)right));}}
?<$Double$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.less((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?and$Boolean$IExpression$false$-13$-13$false$1$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Logic.and(scope,(left \=\= null) ? false \: ((Boolean)left),((IExpression)right));}}
?*$Double$Double$true$-13$-13$false$4$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opTimes((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?is_properties$String$$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return GamaFileType.isProperties(((String)target));}}
?+$GamaPoint$GamaPoint$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.add(((GamaPoint)left),((GamaPoint)right));}}
%"geometry"$"const","false","getter","getGeometricEnvelope","name","envelope","type","geometry"=GamaShape
?predecessors_of$IGraph$Object$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.predecessorsOf(((IGraph)left),((Object)right));}}
(species$14$104$ISpecies=GamaSpeciesType
\!PrometheeDecisionMaking$msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer$promethee_DM$"candidates","criteria"=\n\t\t\t@Override\n\t\t\tpublic Integer execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.multi_criteria.MulticriteriaAnalyzer) target).PrometheeDecisionMaking(scope);  }\n@Override public IType getReturnType() { return Types.get(Integer.class);}
\!primMoveForward$MovingSkill$move$"speed","heading","bounds"=\n\t\t\t@Override\n\t\t\tpublic IPath execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((MovingSkill) target).primMoveForward(scope);  }\n@Override public IType getReturnType() { return Types.get(IPath.class);}
[14$false$false$true$true$entities=EntitiesPlaceHolder
?>$String$String$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greater(((String)left),((String)right));}}
?\:$Object$Object$false$-21$-21$false$0$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Logic.then(scope,((Object)left),((Object)right));}}
%"list"$"of","point","const","false","getter","getPoints","name","points","type","list"=GamaShape
?collate$IList$$false$-13$-16$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Containers.interleave(scope,((IList)target));}}
)user_only=UserOnlyControlArchitecture
[2$false$false$true$false$break=BreakStatement
-setName$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setName((String)arg); }
?rotated_by$IShape$Integer$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.primRotation(((IShape)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?where$GamaMap$IExpression$false$-13$-13$true$6$GamaMap=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaMap execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.where(scope,((GamaMap)left),((IExpression)right));}}
?\!\=$Integer$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
*getPlaces$ITopology=@Override public IContainer value(final IValue v)  { if (v \=\= null) return  (IContainer)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IContainer.class), null) ; \nIContainer result \= ((ITopology) v).getPlaces(); return result;}
%"float"$"const","false","getter","getY","name","y","type","float"=ILocation
[3$false$false$true$true$aspect=AspectStatement
?as_date$double$$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.asDate((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?contains_any$IContainer$IContainer$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opContainsAny(((IContainer)left),((IContainer)right));}}
%"int"$"const","false","getter","red","name","red","type","int"=GamaColor
?distance_between$ITopology$IContainer$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opDistanceBetween(scope,((ITopology)left),((IContainer)right));}}
?\=$Double$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.equal((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
/getTimeStep$WorldSkill=@Override public Double execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  0d ; \n  return (Double)((WorldSkill) target).getTimeStep(agent);}
?-$IMatrix$IMatrix$true$-13$-13$false$5$IMatrix=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IMatrix execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (IMatrix)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IMatrix.class), null) ; \nreturn ((IMatrix) left).minus(((IMatrix)right));}}
%"int"$"const","false","getter","blue","name","blue","type","int"=GamaColor
*getHoles$GamaShape=@Override public GamaList value(final IValue v)  { if (v \=\= null) return  (GamaList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaList.class), null) ; \nGamaList result \= ((GamaShape) v).getHoles(); return result;}
%"rgb"$"const","false","getter","getColor","name","color","setter","setColor","type","rgb"=GridSkill
?solid$IShape$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Transformations.opWithoutHoles(((IShape)target));}}
?*$GamaPoint$Integer$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.multiply(((GamaPoint)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?sqrt$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.sqrt((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
-setUserControlled$UserControlArchitecture=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((UserControlArchitecture) target).setUserControlled(agent, (Boolean)arg); }
*isReadable$IGamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((IGamaFile) v).isReadable(); return result;}
?masked_by$IShape$GamaList$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Operators.opMaskedBy(scope,((IShape)left),((GamaList)right));}}
?eval_gaml$String$$false$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.System.opEvalGaml(scope,((String)target));}}
?sum$IContainer$$true$-16$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope,final Object target, final Object right) { if (target \=\= null) return  (Object)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(Object.class), null) ; \nreturn ((IContainer) target).sum(scope);}}
?inside$ISpecies$Object$false$-13$-20$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opInside(scope,((ISpecies)left),((Object)right));}}
-setWarningsAsErrors$WorldSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((WorldSkill) target).setWarningsAsErrors(agent, (Boolean)arg); }
*getRows$IMatrix=@Override public Integer value(final IValue v)  { if (v \=\= null) return  0 ; \nInteger result \= ((IMatrix) v).getRows(); return result;}
?with_max_of$IContainer$IExpression$false$-20$-13$true$6$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.withMaxOf(scope,((IContainer)left),((IExpression)right));}}
?image$String$$false$-13$-13$false$98$IGamaFile=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGamaFile execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.imageFile(scope,((String)target));}}
%"string"$"const","false","getter","getTotalDuration","name","total_duration","type","string"=WorldSkill
[9$false$false$true$false$hill_climbing=msi.gama.kernel.batch.HillClimbing
*isVerbose$IGraph=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((IGraph) v).isVerbose(); return result;}
%"float"$"initer","getSeed","const","false","getter","getSeed","name","seed","setter","setSeed","type","float"=WorldSkill
?inter$IContainer$IContainer$true$-13$-20$false$5$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.opInter(scope,((IContainer)left),((IContainer)right));}}
?first$ISpecies$$false$-16$-16$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Containers.getFirst(scope,((ISpecies)target));}}
?*$IShape$Double$false$-13$-13$false$4$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opScaledBy(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
%"geometry"$"const","false","getter","getGeometry","name","shape","setter","setGeometry","type","geometry"=IGamlAgent
?last_index_of$GamaMap$Object$true$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opLastIndexOf(((GamaMap)left),((Object)right));}}
?path_to$IShape$IShape$false$-13$-13$false$98$IPath=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IPath execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.opPathTo(scope,((IShape)left),((IShape)right));}}
?<$String$String$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.less(((String)left),((String)right));}}
%"list"$"of","agent","const","false","getter","getAgentList","name","agents","type","list"=IPath
?eval_java$String$$false$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.System.opEvalJava(scope,((String)target));}}
%"point"$"const","false","getter","getEndVertex","name","target","type","point"=IPath
*green$GamaColor=@Override public Integer value(final IValue v)  { if (v \=\= null) return  0 ; \nInteger result \= ((GamaColor) v).green(); return result;}
?round$Integer$$true$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.round((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
?>\=$Double$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greaterOrEqual((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?cone$GamaPoint$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opCone(scope,((GamaPoint)target));}}
?/$GamaColor$Double$true$-13$-13$false$4$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Colors.divide(((GamaColor)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
*getGeometricEnvelope$GamaShape=@Override public GamaShape value(final IValue v)  { if (v \=\= null) return  (GamaShape)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaShape.class), null) ; \nGamaShape result \= ((GamaShape) v).getGeometricEnvelope(); return result;}
&experimentator=msi.gama.kernel.experiment.AbstractExperiment.ExperimentatorPopulation.ExperimentatorAgent
\!primHalt$WorldSkill$halt=\n\t\t\t@Override\n\t\t\tpublic Object execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((WorldSkill) target).primHalt(scope);  }\n@Override public IType getReturnType() { return Types.get(Object.class);}
?<->$Integer$Integer$true$-13$-13$false$0$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.toPoint((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?TGauss$GamaPoint$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opTGauss(scope,((GamaPoint)target));}}
-setSeed$WorldSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((WorldSkill) target).setSeed(agent, (Double)arg); }
?string$Object$$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asString(scope,((Object)target));}}
%"list"$"const","false","getter","getMembers","name","members","setter","setMembers","type","list"=IGamlAgent
&world_species=WorldAgent
?-$Integer$Double$true$-13$-13$false$5$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opMinus((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?as_time$double$$true$-13$-13$false$98$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.asTime((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?agents_overlapping$Object$$false$-13$0$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Queries.opOverlappingAgents(scope,((Object)target));}}
*getPath$GamaFile=@Override public String value(final IValue v)  { if (v \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \nString result \= ((GamaFile) v).getPath(); return result;}
?species_of$Object$$false$-13$-15$false$98$ISpecies=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ISpecies execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asSpecies(scope,((Object)target));}}
?with_min_of$IContainer$IExpression$false$-20$-13$true$6$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.withMinOf(scope,((IContainer)left),((IExpression)right));}}
?index_of$GamaMap$Object$true$-13$-13$false$98$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opIndexOf(((GamaMap)left),((Object)right));}}
\!primFollow$MovingSkill$follow$"speed","path"=\n\t\t\t@Override\n\t\t\tpublic IPath execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((MovingSkill) target).primFollow(scope);  }\n@Override public IType getReturnType() { return Types.get(IPath.class);}
?column_at$IMatrix$Integer$true$-13$-20$false$98$List=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic List execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  (List)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(List.class), null) ; \nreturn ((IMatrix) left).getColumn((right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
(topology$18$104$ITopology=GamaTopologyType
(point$7$104$ILocation$GamaPoint=GamaPointType
?at$ISpecies$Integer$false$-13$-20$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.getAgent(scope,((ISpecies)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
?<->$IShape$IShape$false$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Properties.opDisjoint(scope,((IShape)left),((IShape)right));}}
[11$false$false$false$true$enter=FsmEnterStatement
?\=$Object$Object$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.equal(((Object)left),((Object)right));}}
-setRng$WorldSkill=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((WorldSkill) target).setRng(agent, (String)arg); }
[2$false$false$true$false$user_input=UserInputStatement
*getDimensions$IMatrix=@Override public ILocation value(final IValue v)  { if (v \=\= null) return  (ILocation)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(ILocation.class), null) ; \nILocation result \= ((IMatrix) v).getDimensions(); return result;}
?set_verbose$IGraph$Boolean$false$-13$-13$false$98$IGraph=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGraph execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Graphs.setVerbose(scope,((IGraph)left),(right \=\= null) ? false \: ((Boolean)right));}}
?tanh$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.tanh((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
/getGeometry$IGamlAgent=@Override public IShape execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (IShape)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IShape.class), null) ; \n  return (IShape)((IGamlAgent) target).getGeometry();}
*isReadable$GamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((GamaFile) v).isReadable(); return result;}
?first_with$IContainer$IExpression$false$-20$-13$true$6$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.first_with(scope,((IContainer)left),((IExpression)right));}}
?agent$Object$$false$-13$-13$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asAgent(scope,((Object)target));}}
[11$false$false$false$true$exit=FsmExitStatement
?scaled_by$IShape$Double$false$-13$-13$false$4$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.opScaledBy(((IShape)left),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?.$IAgent$IExpression$false$-17$-19$false$99$Object=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Object execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.System.opGetValue(scope,((IAgent)left),((IExpression)right));}}
?+$GamaPoint$Integer$true$-13$-13$false$98$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.add(((GamaPoint)left),(right \=\= null) ? 0 \: right instanceof Integer ? (Integer) right \: Integer.valueOf(((Number)right).intValue()));}}
*getExteriorRing$GamaShape=@Override public GamaShape value(final IValue v)  { if (v \=\= null) return  (GamaShape)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(GamaShape.class), null) ; \nGamaShape result \= ((GamaShape) v).getExteriorRing(); return result;}
?of_generic_species$IList$ISpecies$false$-13$-19$false$3$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opOfGenericSpecies(((IList)left),((ISpecies)right));}}
[2$false$false$true$false$set=SetStatement
?ln$Double$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.ln((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?is_number$String$$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Strings.isGamaNumber(((String)target));}}
?link$GamaPair$$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Spatial.Creation.opLink(scope,((GamaPair)target));}}
?not$Boolean$$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Logic.not((target \=\= null) ? false \: ((Boolean)target));}}
[11$true$false$true$true$migrate=MigrateStatement
?is_text$String$$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return GamaFileType.isTextFile(((String)target));}}
?\!\=$Double$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
[3$false$true$true$true$primitive=PrimitiveStatement
?truncated_gauss$GamaPoint$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opTGauss(scope,((GamaPoint)target));}}
*getName$GamaFile=@Override public String value(final IValue v)  { if (v \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \nString result \= ((GamaFile) v).getName(); return result;}
%"float"$"const","false","getter","getWidth","name","width","type","float"=GamaShape
?<->$Double$Double$true$-13$-13$false$0$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.toPoint((left \=\= null) ? 0d \: left instanceof Double ? (Double) left \: Double.valueOf(((Number)left).doubleValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?overlapping$ISpecies$Object$false$-13$-20$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Queries.opOverlapping(scope,((ISpecies)left),((Object)right));}}
%"float"$"const","false","getter","getHeight","name","height","type","float"=GamaShape
/getSpeed$MovingSkill=@Override public Double execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  0d ; \n  return (Double)((MovingSkill) target).getSpeed(agent);}
?+$Integer$Double$true$-13$-13$false$5$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Maths.opPlus((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
[2$false$false$true$false$arg=ArgStatement
[6$false$false$true$true$population=msi.gama.outputs.layers.SpeciesLayerStatement
?>\=$String$String$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.greaterOrEqual(((String)left),((String)right));}}
\!primClusteringSimpleKMeans$msi.gaml.extensions.cluster_builder.ClusterBuilder$clustering_simple_kmeans$"agents","attributes","distance_f","dont_replace_missing_values","max_iterations","num_clusters","preserve_instances_order","seed"=\n\t\t\t@Override\n\t\t\tpublic List execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((msi.gaml.extensions.cluster_builder.ClusterBuilder) target).primClusteringSimpleKMeans(scope);  }\n@Override public IType getReturnType() { return Types.get(List.class);}
[11$false$false$true$true$chain=PertinenceChainStatement
?neighbours_of$IGraph$Object$false$-13$-13$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.neighboursOf(((IGraph)left),((Object)right));}}
?intersection$IShape$IShape$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.opInter(((IShape)left),((IShape)right));}}
\!primDebug$GamlAgent$debug$"message"=\n\t\t\t@Override\n\t\t\tpublic Object execute(final ISkill target, IAgent agent, final IScope scope) { \n return ((GamlAgent) target).primDebug(scope);  }\n@Override public IType getReturnType() { return Types.get(Object.class);}
?-$IList$IList$true$-13$-20$false$5$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opMinus(((IList)left),((IList)right));}}
%"float"$"const","true","getter","getTimeStep","name","step","setter","setTimeStep","type","float"=WorldSkill
[2$false$false$true$false$return=ReturnStatement
?\!$Boolean$$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Logic.not((target \=\= null) ? false \: ((Boolean)target));}}
%"bool"$"const","false","getter","isMultiple","name","multiple","type","bool"=GamaShape
*getEdges$IGraph=@Override public IList value(final IValue v)  { if (v \=\= null) return  (IList)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(IList.class), null) ; \nIList result \= ((IGraph) v).getEdges(); return result;}
?standard_deviation$GamaList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Stats.opStDev(scope,((GamaList)target));}}
[11$true$false$true$false$capture=CaptureStatement
%"point"$"const","false","getter","getStartVertex","name","source","type","point"=IPath
?rgb$Object$$true$-13$-13$false$98$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asColor(scope,((Object)target));}}
-setPeers$IGamlAgent=@Override public void execute(final IAgent agent, final ISkill target, final Object arg) { if (target \=\= null) return;  \n((IGamlAgent) target).setPeers((IList)arg); }
?union$IShape$IShape$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Operators.opUnion(((IShape)left),((IShape)right));}}
factories=msi.gaml.factories.ExperimentFactory¤msi.gaml.factories.SpeciesFactory¤msi.gaml.factories.ModelFactory¤msi.gama.outputs.layers.OutputLayerFactory¤msi.gaml.factories.SymbolFactory¤msi.gaml.factories.StatementFactory¤msi.gaml.factories.BatchFactory¤msi.gaml.factories.VariableFactory¤msi.gaml.factories.OutputFactory
[5$false$false$true$false$monitor=msi.gama.outputs.MonitorOutput
?select$IContainer$IExpression$false$-13$-20$true$6$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.where(scope,((IContainer)left),((IExpression)right));}}
%"unknown"$"const","false","getter","last","name","value","type","unknown"=GamaPair
?disjoint_from$IShape$IShape$false$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Properties.opDisjoint(scope,((IShape)left),((IShape)right));}}
%"bool"$"initer","isWritable","const","false","getter","isWritable","name","writable","type","bool"=IGamaFile
%"int"$"const","false","getter","green","name","green","type","int"=GamaColor
[104$false$false$true$false=Variable
?\:\:$Object$Object$true$9$-17$false$0$GamaPair=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaPair execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Containers.opPair(((Object)left),((Object)right));}}
?folder$String$$false$-13$-13$false$98$IGamaFile=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IGamaFile execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Files.folderFile(scope,((String)target));}}
?is_shape$String$$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object target, final Object right) { return GamaFileType.isShape(((String)target));}}
%"int"$"const","false","getter","getRows","name","rows","type","int"=IMatrix
/isUserControlled$UserControlArchitecture=@Override public Boolean execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  false ; \n  return (Boolean)((UserControlArchitecture) target).isUserControlled(agent);}
?species$Object$$false$-13$-15$false$98$ISpecies=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ISpecies execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asSpecies(scope,((Object)target));}}
?@$ISpecies$GamaPoint$false$-13$-20$false$98$IAgent=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IAgent execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.getAgent(scope,((ISpecies)left),((GamaPoint)right));}}
?geometric_mean$GamaList$$false$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Stats.opGeomMean(scope,((GamaList)target));}}
*getWidth$GamaShape=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((GamaShape) v).getWidth(); return result;}
?contains_all$String$List$true$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Strings.opContainsAll(((String)left),((List)right));}}
?translated_to$IShape$ILocation$false$-13$-13$false$98$IShape=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IShape execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Spatial.Transformations.primTranslationTo(((IShape)left),((ILocation)right));}}
?rnd$Double$$false$-13$-13$false$98$Integer=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Integer execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opRnd(scope,(target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
?ceil$double$$true$-13$-13$false$98$double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.ceil((target \=\= null) ? 0d \: target instanceof Double ? (Double) target \: Double.valueOf(((Number)target).doubleValue()));}}
[6$false$false$true$false$agents=msi.gama.outputs.layers.AgentLayerStatement
?+$String$Object$true$-13$-13$false$5$String=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic String execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Strings.opPlus(scope,((String)left),((Object)right));}}
*exists$IGamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((IGamaFile) v).exists(); return result;}
?<->$Integer$Double$true$-13$-13$false$0$ILocation=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic ILocation execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Points.toPoint((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
?contains$IContainer$Object$true$-13$-13$false$98$boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope,final Object left, final Object right) { if (left \=\= null) return  false ; \nreturn ((IContainer) left).contains(((Object)right));}}
?path_between$ITopology$IContainer$false$-13$-20$false$98$IPath=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IPath execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Spatial.Relations.pathBetween(scope,((ITopology)left),((IContainer)right));}}
?accumulate$IList$IExpression$false$-13$-19$true$6$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object left, final Object right) { return msi.gaml.operators.Containers.accumulate(scope,((IList)left),((IExpression)right));}}
?contains_vertex$GamaGraph$Object$false$-13$-13$false$98$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Graphs.containsVertex(((GamaGraph)left),((Object)right));}}
[4$false$false$true$false$parameter=msi.gama.kernel.experiment.ExperimentParameter
?map$Object$$true$-13$-13$false$98$GamaMap=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaMap execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Cast.asMap(scope,((Object)target));}}
?shuffle$IList$$false$-13$-16$false$98$IList=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic IList execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Random.opShuffle(scope,((IList)target));}}
*isFolder$IGamaFile=@Override public Boolean value(final IValue v)  { if (v \=\= null) return  false ; \nBoolean result \= ((IGamaFile) v).isFolder(); return result;}
?<$Integer$Double$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.less((left \=\= null) ? 0 \: left instanceof Integer ? (Integer) left \: Integer.valueOf(((Number)left).intValue()),(right \=\= null) ? 0d \: right instanceof Double ? (Double) right \: Double.valueOf(((Number)right).doubleValue()));}}
%"int"$"const","false","getter","getHeading","name","heading","setter","setHeading","init","rnd\ 359","type","int"=MovingSkill
*getName$GamlSpecies=@Override public String value(final IValue v)  { if (v \=\= null) return  (String)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(String.class), null) ; \nString result \= ((GamlSpecies) v).getName(); return result;}
?+$GamaColor$GamaColor$true$-13$-13$false$5$GamaColor=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic GamaColor execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Colors.add(((GamaColor)left),((GamaColor)right));}}
?\!\=$Object$Object$true$-13$-13$false$2$Boolean=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Boolean execute(final IScope scope, final Object left, final Object right)  { return msi.gaml.operators.Comparison.different(((Object)left),((Object)right));}}
*getArea$GamaShape=@Override public Double value(final IValue v)  { if (v \=\= null) return  0d ; \nDouble result \= ((GamaShape) v).getArea(); return result;}
%"list"$"const","false","getter","getValues","name","values","type","list"=GamaMap
/getTopology$IGamlAgent=@Override public ITopology execute(final IAgent agent, final ISkill target) { if (target \=\= null) return  (ITopology)msi.gaml.types.Types.coerce(null, (Object) null, msi.gaml.types.Types.get(ITopology.class), null) ; \n  return (ITopology)((IGamlAgent) target).getTopology();}
?ln$Integer$$true$-13$-13$false$98$Double=\n\t\t\tnew IOperatorExecuter() {\n\t\t\t@Override\n\t\t\tpublic Double execute(final IScope scope, final Object target, final Object right) { return msi.gaml.operators.Maths.ln((target \=\= null) ? 0 \: target instanceof Integer ? (Integer) target \: Integer.valueOf(((Number)target).intValue()));}}
